<!doctype html>
<html>
<head>
<meta charset=utf-8>
<title>sixty.nw</title>
<style>
body {
  font-size: 120%;
  padding-left: 5em;
  padding-top: 2em;
  max-width: 50rem;
  line-height: 1.2;
}
table {
  margin: 1em;
  margin-left: -2em;
  border-collapse: collapse;
}
table td, table th {
  font-family: monospace;
  white-space: pre;
  border: 1px solid #ccc;
  padding: 0.5em;
}
table.dense {
  table-layout: fixed;
  width: 1100px;
}
table.dense td, table.dense th {
  padding: 2px 8px;
}
.given {
  background: #eff3ff;
}
.given2 {
  background: #ffd7f1;
}
.dummy {
  background: #efefef;
}
</style>
</head>
<body>
<h1>Reconstruction of ENIAC 60 order code</h1>
(after <a href="https://ftp.arl.army.mil/~mike/comphist/48eniac-coding/">Clippinger 1948:
A Logical Coding System Applied to the ENIAC</a>)

<p>The 60 order code was a research instruction set for the ENIAC with 60
instructions, planned in detail but never installed.  It was designed for the
original ENIAC hardware with a few minimal additions.  <em>ENIAC in Action</em>
says that the wiring charts are in a box in the US National Archives&mdash;this
is an independent reconstruction based on a 1948 report (LCS48) and other
documents available on the web.

<p>LCS48 is both extremely detailed, giving many exact <a href="#prog">program
line assignments</a>, and silent on harder questions like what exactly the plan
was for <a href="#shifts">shifts</a>.  The 1949 report
<a href="https://eniacinaction.com/docs/DescriptionandUse1949.pdf">Description
and Use of the ENIAC Converter Code</a> (DU49) describes a derived instruction
set in better detail and offers some clues.  Also of interest is the much later
1951 <a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/642030.pdf">Description
of the Eniac Converter Code</a> (DEC51), by which time the instruction set had
graduated from research status to admit contract programming services and
computer rental for $35/hr or $800/day.

<p>One <a href="http://opentranscripts.org/wp-content/uploads/2016/02/working-on-eniac-0071-1280x960.jpg">random
image file</a> (RIF) on the Internet shows a tantalizing excerpt of a
hand-written program line index from late 1947 which matches up with many
assignments in LCS48.

<p>The <a
href="https://www.amazon.com/Electronic-Numerical-Integrator-Computer-Technical/dp/1937684660">ENIAC
Technical Manual</a> (ETM) is helpful for clarifying how the machine is
supposed to work, and makes for great bedtime reading.

<h2>General notes</h2>

<p><b>This file.</b>  This file has been prepared using the <a
href="https://www.cs.tufts.edu/~nr/noweb/">noweb</a> literate programming
system.  Code &lt;blocks&gt; like the one below are interleaved with
this text, and <tt>noweb</tt> pastes them together.  You can rebuild both this
document and an input file for the <a
href="https://github.com/jeredw/eniacsim">eniacsim</a> simulator with
<tt>make</tt>.

<<File header>>=
# Generated by noweb, do not edit.  Use make to rebuild from sixty.nw.
# Input file for eniacsim (https://github.com/jeredw/eniacsim)
@

<p><b>Timings.</b> Knowing how long an instruction takes might be helpful to
guess how it works, but LCS48 cycle timings are suspiciously low for some
instructions like <a href="#multiply"><tt>X</tt></a>&mdash;perhaps the marketing
department got hold of it. DU49 has more conservative timings despite its faster
6 cycle fetch, so is likely more reliable. DEC51 differs yet again but more
closely matches DU49.

<p>This reconstruction keeps execution time for 7-cycle instructions in LCS48 at
7 cycles and does its best to match the rest. Timing considerations make an
interesting difference for <a href="#cflow">control flow</a> instructions, and
<a href="#shifts">shifts</a> just have issues.

<p><b>Reserving A<sub>13</sub>.</b> Several instructions require
A<sub>13</sub> to be 0 before execution and guarantee it to be 0 after.  This
is indicated as <q>Acc. 13 0 0</q> in the before and after columns in LCS48
Section IV, notation that DU49 clarifies with an explicit footnote.

<p>While by modern standards it's ugly that this leaks into the ISA, presence or
absence of this note is key information for several instruction sequences. DEC51
goes one step further and says what will happen if A<sub>13</sub> is
<em>not</em> 0 beforehand, which hints at auxiliary <a
href="#acc-inputs">inputs</a>.

<blockquote>The <q>bad</q> effects of not having 13 clear in the various
instructions that <q>require</q> it to be clear may occasionally prove
useful.</blockquote>

<p>It's amusing to think programmers might have abused these quirks in a way
reminiscent of <a href="https://en.wikipedia.org/wiki/Illegal_opcode">illegal
opcodes</a> later on.

<p><b>Accumulator <a name="#acc-inputs">inputs</a>.</b> Many
instructions require shifting digits, and that must be done at accumulator
inputs.  There are 20&times;5 inputs, so you wouldn't expect this to be a
bottleneck, but the instruction set places a lot of pressure on A<sub>13</sub>
and A<sub>15</sub>.  Two of A<sub>13</sub> and A<sub>15</sub>'s ten inputs are
tied up for the multiplier, and most of the rest have implied connections to
support instructions that don't reserve A<sub>13</sub>.

<p>When A<sub>13</sub> is reserved, it's possible to stash A<sub>n</sub> in
A<sub>13</sub>, use one of A<sub>n</sub>'s inputs, and then transfer the answer
and restore A<sub>n</sub>.  For example, the LCS48 paragraph about
<tt>C.T.</tt> mentions using a shifter on A<sub>10</sub> to accomplish the
required PC shift this way.  This is corroborated in DEC51,
<blockquote>If 13 is not clear, its number will be subtracted from 10
(10-13&rarr;10) on the positive branch.</blockquote>

<p>The reconstructed input wiring is summarized in this
<a href="#inputs">chart</a>.

<p><b>Reusing programs.</b> A<sub>15</sub> and A<sub>13</sub> are used for most
instructions, so their programs must be <a href="#common">reused</a> for
multiple sequences.  This is accomplished with both <a href="#amps">pulse
amplifiers</a> and dummy programs.

<p>Pulse amplifiers are more convenient because dummy programs introduce an
extra delay cycle, but are scarce&mdash;LCS48 states there are eight units with
11 channels and claims all but 23 of them in Table 2.II.

<p>For dummy programs, apart from accumulator transceivers, there are six
selective clear transceivers, and twenty unused constant transceivers.  <a
href="#trunks">Digit trunk</a> wiring makes the constant transceivers somewhat
difficult to abuse for this purpose because we must avoid contention on trunk
1.

<h2>Implementation</h2>

<<*>>=
<<File header>>
<<Reset>>
<<Fetch sequence>>
<<Decode>>
<<Digit trunks>>
<<Pulse amplifiers>>
<<Instructions>>
@

<h3>Reset</h3>

<p>The initial clear sequence clears accumulators, including the PC, but not the
ft selector or order selector. So we need to clear those as part of the initiate
sequence to begin fetch at the start of the first function table row.

<<Reset>>=
# Initiate pulse triggers A-1
p i.Io A-1

# Pulse amplifiers clear order selector and ft selector
# (A-1 -> G-6, A-1 -> E-9)
p G-6 os.Ci

# Dummy program to start fetch next cycle
p A-1 a2.12i
s a2.op12 0
s a2.cc12 0
s a2.rp12 1
p a2.12o C-5
@ %def A-1 G-6

<h3>Fetch sequence</h3>

<p>Here we set up the 7-cycle instruction fetch sequence described in
LCS48 <em>II: Conversion of digit pulses to programming pulses</em>.
Parts of the sequence are reused to fetch arguments for <tt>NxD</tt> so are
separately controllable, e.g. <tt>N6D</tt> triggers [[D-6]]&rarr;[[J-2]],
[[E-1]] but not [[C-5]], so it will read from the function table but not decode
a new instruction.

<p>The sequence is summarized in LCS48 Figure 2.2, which is redrawn as
implemented here with changes <s>crossed out</s>.

<table>
<tr>
<th>
<th>F.T. sel
<th>Order<br>sel
<th>10-stage<br>stepper
<th>Master<br>prog.
<th>Acc 6
<th>Acc 20
<th>FT I
<th>FT II
<th>FT III
<th>SC</th>

<tr>
<td>0
<td>[[E-1]] i#1
[[E-8]] di 
1&rarr;[[E-11]]
2&rarr;[[F-1]]
3&rarr;[[F-2]]
<td><td><td>
<td>[[J-2]]
 A01 
  [[E-9]]
<td>[[C-5]]
 <s>006</s>
 005
  [[E-10]]
<td><td><td><td>
<tr>
<td>1
<td>[[E-9]] <s>i#2</s>
 cdi
<td><td><td><td><td>|
<td>[[E-11]]
NC
 [[J-4]]
<td>[[F-1]]
NC
 [[J-4]]
<td>[[F-2]]
NC
 [[J-4]]
<td></td>

<tr>
<td>2
<td><td><td><td><td>J-4   
 A01
  [[F-3]]
<td>|<td>|<td>|<td>|<td></td>

<tr>
<td>3
<td><td>[[F-3]]
 CPP1
  [[F-4]]
<td><td><td><td>|<td>|<td>|<td>|<td>[[F-3]]
 001
  [[F-5]]

<tr>
<td>4
<td><td><td>[[F-5]]
 cdi
<td>[[F-5]]
 cdi
<td>[[F-4]]
 εC1
<s>[[F-5]]</s>
 <s>002</s>
  <s>[[G-8]]</s>
<td>|<td>|<td>|<td>|<td>[[F-5]]
 001
  [[G-8]]

<tr>
<td>5<td><td>[[G-8]]
 i
<td>* di
[[E-10]]
 i
<td>* di
<td><td>x<td>x<td>x<td>x<td>

<tr>
<td>6
<td><td><s>G-8</s>
 <s>i</s><td><s>[[E-10]]</s>
 <s>i</s><td>Xi
 CPP
  Xko
  (&rarr;[[C-5]])<td><td><td><td><td><td>

<tr style="border-top: 3px solid #ccc; background: #eee;">
<td>0
<td><td><td><td><td><td>[[C-5]]&hellip;<td><td><td><td>
</table>

<p>Cycle 0 decodes the hundreds digit of the PC (A<sub>6</sub>) to select one
of three function tables.  The function table read takes five cycles, with data
returning in cycle 5.  The order selector must thus multiplex data to the
decoder stepper direct inputs in cycle 5.  In cycle 6 the ten stage stepper
output triggers the correct MP stepper input, so that in cycle 7 &equiv; 0 the
MP output corresponding to the instruction and possibly [[C-5]] can be
asserted.

<h4>Changes</h4>

<ol>
<li>[[E-10]] just seems mistimed.  ETM X-6 is clear that for MP steppers,
<blockquote>A program pulse received at the end of addition time t...
sets the input flip-flop.  The normally negative output of this flip-flop then
opens gate 69 so that a CPP passes through at the end of addition time
t+1.</blockquote>  MP output is at the end of cycle 6, so the input from the
ten stage stepper must be setup at the end of cycle 5, which in turn means its
input needs to arrive at the end of cycle 4.
<li>It is unclear what [[E-9]] is for or what the annotation <tt>i#2</tt>
means.  The ft selector stepper needs to be cleared somehow, so assume it is
for that.
<li>If [[G-8]] is an output enable for the order selector, it is also late.
It's possible [[G-8]] was meant to step the order selector ring, and [[F-4]]
was meant to trigger when it is on the last stage?  In <tt>eniacsim</tt>, the
<a href="https://github.com/jeredw/eniacsim/blob/master/lib/units/ordersel.go">order
selector</a> is built so that [[F-3]] actually steps it, and [[F-4]] triggers
when it has overflowed; the <tt>i</tt> input just gates output digits.
<p>RIF has [[F-5]] trigger [[G-8]] one cycle later via a dummy program on SC#1.
</ol>

<h4>Code</h4>

<<Fetch sequence>>=
# Fetch sequence
# This sequence takes 7 cycles, so that is the minimum instruction latency.
# Many instructions overlap execution with fetching the next instruction.

# Cycle 0: Select function table.
<<Fetch sequence: cycle 0>>
# Cycle 1: Initiate function table read.
<<Fetch sequence: cycle 1>>
# Cycle 2: Send function table argument.
<<Fetch sequence: cycle 2>>
# Cycle 3: Step order selector ring.
<<Fetch sequence: cycle 3>>
# Cycle 4: Clear decoder steppers and increment PC.
<<Fetch sequence: cycle 4>>
# Cycle 5: Decode instruction data.
<<Fetch sequence: cycle 5>>
# Cycle 6: Wait for MP decoder.
<<Fetch sequence: cycle 6>>
@

<h4>Fetch cycle 0</h4>
<<Fetch sequence: cycle 0>>=
# Select the FT to read.
# Decode E-8=0,1,2 into E-11, F-1, or F-2.
p E-1 sft.i
p E-8 sft.di
p sft.1o E-11
p sft.2o F-1
p sft.3o F-2

# Send PC on trunk 3.
p J-2 a6.5i
s a6.op5 A
s a6.cc5 0
s a6.rp5 1
p a6.5o E-9

# Await instruction data.
p C-5 a20.12i
s a20.op12 0
s a20.cc12 0
s a20.rp12 5
p a20.12o E-10
@ %def E-11 F-1 F-2 E-9 E-10

<h4>Fetch cycle 1</h4>

<p>Note that instructions use A-2 addressing; see the notes about the
<code><a href="#ft"> F.T.</a></code> instruction.

<<Fetch sequence: cycle 1>>=
# Clear FT selector for next fetch.
p E-9 sft.cdi

# Initiate instruction or operand read.
p E-11 f1.1i
s f1.op1 A-2
s f1.cl1 NC
s f1.rp1 1
p f1.NC J-4

p F-1 f2.1i
s f2.op1 A-2
s f2.cl1 NC
s f2.rp1 1
p f2.NC J-4

p F-2 f3.1i
s f3.op1 A-2
s f3.cl1 NC
s f3.rp1 1
p f3.NC J-4
@ %def J-4

<h4>Fetch cycle 2</h4>
<<Fetch sequence: cycle 2>>=
# Send value for FT argument.
# Note this is also used by the 6(11,10,9) and 6(8,7) sequences.
p J-4 a6.6i
s a6.op6 A
s a6.cc6 0
s a6.rp6 1
p a6.6o F-3
@ %def F-3

<h4>Fetch 3</h4>
<<Fetch sequence: cycle 3>>=
# Step the instruction ring counter.
p F-3 os.Ri
p os.Ro F-4  # overflow -> inc PC

# Dummy program to trigger Fetch 4.
p F-3 i.Ci4
p i.Co4 F-5
@ %def F-4 F-5

<h4>Fetch cycle 4</h4>

<p>LCS48 places both the PC increment triggered by [[F-4]] and the [[G-8]]
dummy program on A<sub>6</sub> in this cycle.  ETM doesn't clearly specify the
behavior of simultaneous programs on an accumulator, but warns against it, so
this is fishy.  It should probably work, though?  We follow RIF which places
the [[G-8]] dummy program on SC#1 instead.

<<Fetch sequence: cycle 4>>=
# Clear steppers prior to decode
p F-5 st.cdi
p F-5 p.Acdi
p F-5 p.Bcdi
p F-5 p.Ccdi
p F-5 p.Dcdi
p F-5 p.Ecdi
p F-5 p.Fcdi
p F-5 p.Gcdi
p F-5 p.Hcdi
p F-5 p.Jcdi
p F-5 p.Kcdi

# Increment PC if order selector wrapped
p F-4 a6.1i
s a6.op1 ε
s a6.cc1 C
# Dummy to enable order selector output next cycle.
p F-5 i.Ci1
p G-8 i.Co1
@ %def G-8

<h4>Fetch cycle 5</h4>
<<Fetch sequence: cycle 5>>=
# Order selector passes FT data.
p G-8 os.i

# Decode tens digit and trigger corresponding MP stepper input.
# Since only B-2 and B-5 are documented by available sources, just wire up
# the other ten stage stepper outputs directly.
p E-10 st.i
p F-6 st.di
p st.1o B-2
p B-2 p.Ai
p st.2o B-5
p B-5 p.Bi
p st.3o p.Ci
p st.4o p.Di
p st.5o p.Ei
p st.6o p.Fi
p st.7o p.Gi
p st.8o p.Hi
p st.9o p.Ji
p st.10o p.Ki

# Decode ones digit.
p E-2 p.Adi
p E-2 p.Bdi
p E-2 p.Cdi
p E-2 p.Ddi
p E-2 p.Edi
p E-2 p.Fdi
p E-2 p.Gdi
p E-2 p.Hdi
p E-2 p.Jdi
p E-2 p.Kdi

<<Fetch sequence: configure MP for decoding>>
@ %def B-2 B-5

<p>MP steppers must be set to use all 6 positions since we want to decode 0-5.
We don't want to use MP decades, but if the decade switches are set to zero,
they'll overflow every cycle and steppers will be free running&mdash;in
particular they'll increment during the cdi cycle.  So decade switches must be
nonzero.  <tt><i>X</i>i</tt> will trigger a decade counter increment, which
might cause a spurious step next cycle, but the correct output will still
trigger this cycle.

<<Fetch sequence: configure MP for decoding>>=
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6
# Set decade switches to nonzero values so that steppers don't cycle in between
# cdi and the decode cycle.
s p.d1s1 1
s p.d2s1 1
s p.d3s1 1
s p.d4s1 1
s p.d5s1 1
s p.d6s1 1
s p.d7s1 1
s p.d8s1 1
s p.d9s1 1
s p.d10s1 1
s p.d11s1 1
s p.d12s1 1
s p.d13s1 1
s p.d14s1 1
s p.d15s1 1
s p.d16s1 1
s p.d17s1 1
s p.d18s1 1
s p.d19s1 1
s p.d20s1 1
@

<h4>Fetch cycle 6</h4>
<<Fetch sequence: cycle 6>>=
# Waiting for MP decoder to propagate stepper input to output.
@

<h3><a name=decode>Decode</a></h3>

<p>Decode opcodes to program lines following LCS48 Table 2.I.

<p>LCS48 describes two slightly different instruction sets, a <q>regular
code</q> and an <q>alternate code</q> with seven variant instructions. Alternate
instructions are annotated below as <em>n</em>a where <em>n</em> is the opcode.

<p>The sample programs in LCS48 use the regular code, so that's what is wired
up here.  In some cases wiring for the alternate code is left present but
commented out.  DU49 seems to have merged the two instruction sets.

<<Decode>>=
# Decode MP stepper outputs to program lines.

# xl
<<Decode: xl>>
# xt
<<Decode: xt>>
# Arithmetic instructions
<<Decode: arithmetic>>
# Alternate instruction set
<<Decode: alternate instructions>>
# Control flow
<<Decode: control flow>>
# I/O
<<Decode: I/O>>

# Miscellaneous
#p p.H2o      # Halt       (71)  NB doesn't decode to anything, so stops
p p.K2o C-3   # 18↔20      (91)  9 cycles
p p.K3o V-2   # 6(11,10,9) (92)
p p.K4o V-4   # 6(8,7)     (93)
@ %def C-3 V-2 V-4

<h4>x<sub>l</sub></h4>

<<Decode: xl>>=
p p.A2o S-1   # 1l  (01)
p p.A3o S-2   # 2l  (02)
p p.A4o S-3   # 3l  (03)
p p.A5o S-4   # 4l  (04)
p p.A6o S-5   # 5l  (05)
p p.B1o S-6   # 7l  (10)
p p.B2o L-7   # 8l  (11)
p p.B3o L-8   # 9l  (12)
p p.B4o L-9   # 10l (13)
p p.B5o L-10  # 11l (14)
p p.B6o L-11  # 12l (15)
p p.C1o C-7   # 13l (20)  NB a13 += a15, doesn't clear first
p p.C2o H-1   # 14l (21)
p p.C3o H-2   # 16l (22)
p p.C4o H-3   # 17l (23)
p p.C5o H-4   # 18l (24)
p p.C6o H-5   # 19l (25)
@ %def S-1 S-2 S-3 S-4 S-5 S-6 L-7 L-8 L-9 L-10 L-11 C-7 H-1 H-2 H-3 H-4 H-5

<h4>x<sub>t</sub></h4>

<<Decode: xt>>=
p p.D2o V-9   # 1t  (31)
p p.D3o S-7   # 2t  (32)
p p.D4o S-8   # 3t  (33)
p p.D5o S-9   # 4t  (34)
p p.D6o S-10  # 5t  (35)
p p.E1o S-11  # 7t  (40)
p p.E2o C-2   # 8t  (41)
p p.E3o L-1   # 9t  (42)
p p.E4o L-2   # 10t (43)
p p.E5o L-3   # 11t (44)
p p.E6o L-4   # 12t (45)
p p.F1o L-5   # 13t (50)  NB clears after sending
p p.F2o L-6   # 14t (51)
p p.F3o C-9   # 16t (52)
p p.F4o H-6   # 17t (53)
p p.F5o H-7   # 18t (54)
p p.G5o H-8   # 19t (64)
@ %def V-9 S-7 S-8 S-9 S-10 S-11 C-2 L-1 L-2 L-3 L-4 L-5 L-6 C-9 H-6 H-7 H-8

<h4>Arithmetic</h4>

<p><code>C</code> decodes into [[C-1]] which is the generic <code>xl</code>
program line for all listen orders.

<<Decode: arithmetic>>=
p p.A1o C-1   # C   (00)  (also the general xl)
p p.D1o E-5   # X   (30)  "15 cycles"
p p.F6o E-3   # ÷   (55)  ~75 cycles
p p.G1o B-1   # √   (60)  ~75 cycles
p p.G4o V-3   # M   (63)
p p.G6o H-10  # DS  (65)
p p.J6o C-10  # Sh' (85)  20 cycles
p p.K1o C-11  # Sh  (90)  20 cycles
@ %def E-5 E-3 B-1 C-10 C-11 V-3 H-10

<h4>Control flow</h4>

<<Decode: control flow>>=
p p.H6o G-2   # C.T.(75)  14/8 cycles
p p.H4o E-6   # 6R3 (73)  13 cycles
p p.H5o E-7   # 6R6 (74)  13 cycles
@ %def G-2 E-6 E-7

<h4>I/O</h4>

<<Decode: I/O>>=
p p.G2o O-1   # Pr. (61)  60 cards / min
p p.G3o O-2   # Rd. (62)  100 cards / min
p p.H3o H-11  # F.T.(72)  13 cycles
p p.H1o V-5   # N2D (70)  14 cycles
p p.K5o V-6   # N4D (94)  20 cycles
p p.K6o V-7   # N6D (95)  26 cycles
p p.J1o D-7   # AB  (80)
p p.J2o D-8   # CD  (81)
p p.J3o D-9   # EF  (82)
p p.J4o D-10  # GH  (83)
p p.J5o D-11  # JK  (84)
@ %def O-1 O-2 H-11 V-5 V-6 V-7 D-7 D-8 D-9 D-10 D-11

<h4>Alternate instructions</h4>

<<Decode: alternate instructions>>=
#p p.K2o C-8  # 20l (91a)
#p p.H4o E-4  # 6l  (73a) 9 cycles
#p p.H5o V-1  # 6t  (74a)
# Table 2.I has "H-0" for order 92a. Assume this is a typo for H-9 which is the
# only H-line missing, and makes sense from pulse amplifier grouping.
#p p.K3o H-9  # 20t  (92a)
#p p.K4o V-8  # N3D8 (93a) 20 cycles
#p p.K5o ???  # N3D6 (94a) 20 cycles
#p p.K6o ???  # N6D6 (95a) 26 cycles
@ %def C-8 E-4 V-1 H-9 V-8

<h3><a name=trunks>Digit trunks</a></h3>

<p>LCS48 has a note to <q>see digit tray hook-up</q>, so perhaps the
author meant to attach a chart.  Alas there is none, so this is guesswork.

<p>All LCS48 tells us explicitly is that for <code>1ℓ</code>, <tt>a1.α=2</tt>
and <tt>a15.A=2</tt>; and for <code>AB</code>, figure 3.2 has <tt>c.o=1</tt>,
<tt>a11.δ=1</tt>, and <tt>a15.β=1</tt>.  (This last assignment overlaps with the
canonical multiplier correction wiring from ETM, which has the correction term
on <tt>a15.β</tt>, but it's plausible that's shared.)  However, Table 2.II
shows the pulse amplifier connections [[D-3]]&rarr;[[B-3]] and
[[D-4]]&rarr;[[B-3]], that is, both <code>xt</code> and constant instructions
trigger <tt>a15:β01</tt>.  So constants and most accumulators transmit on trunk
1, and A<sub>15</sub> transmits on trunk 2.

<p>That [[D-3]] pulse amplifier wiring omits <code>8t</code> suggests
A<sub>8</sub> and A<sub>6</sub> do not transmit the function table argument on
trunk 1.  It's simplest for fetch overlap if they use another auxiliary trunk
3.

<p>RIF annotates order selector ouptut as II<sub>2</sub>, II<sub>1</sub>,
implying instructions are also on trunk 2.
 
<h4>Reconstructed wiring</h4>

<p>Here is a <a name=inputs>chart</a> of accumulator digit terminals used in
this reconstruction, and their connections. The base number gives the digit
trunk, and any superscript or annotation indicates a connected adapter.

<table style="text-align:center">
<tr>
<th>
<th>[[a1]]<br>
<th>[[a2]]<br>
<th>[[a3]]<br>
<th>[[a4]]<br>Quot.
<th>[[a5]]<br>Num
<th>[[a6]]<br>PC
<th>[[a7]]<br>Denom.
<th>[[a8]]<br>Arg.
<th>[[a9]]<br>Shift
<th>[[a10]]<br>
<th>[[a11]]<br>Ier
<th>[[a12]]<br>Icand
<th>[[a13]]<br>LHPP
<th>[[a14]]<br>
<th>[[a15]]<br>RHPP
<th>[[a16]]<br>
<th>[[a17]]<br>
<th>[[a18]]<br>
<th>[[a19]]<br>
<th>[[a20]]<br>
<tr><td>α<td>2<td>2<td>2<td>10<td>2<td>2<td>2<td>2<td><a href="#11s">11*</a><td>2<td>2<td>2<td>6<td>2<td>7<td>2<td>2<td>2<td>2<td>2
<tr><td>β<td>1<td>1<td>1<td>2<td><td><a href="#1c">1<sup>c</sup><td>1<td><td>2<td><a href="#3c">3<sup>c</sup></a><td><a href="#4s">4*</a><td>1<td>8=2<td>1<td>9=1<td>1<td>1<td><td>1<td>1
<tr><td>γ<td><td><td><td>1<td>11=1<td><a href="#1d">1<sup>d</sup><td>10<td><td>1<td><a href="#3d">3<sup>d</sup></a><td><a href="#1f">1<sup>f</sup><td><td>1<td><td><a href="#5s">5*</a><td><td><td><a href="#2g">2<sup>g</sup></a><td><td>
<tr><td>δ<td><a href="#3a">3<sup>a</sup></a><td>2<sup>+1</sup><td>2<sup>+2</sup><td>2<sup>+3</sup><td>2<sup>+4</sup><td><a href="#2a">2<sup>a</sup></a><td>2<sup>+5</sup><td><td>2<sup>-5</sup><td><td>1<td><td><td>2<sup>-4</sup><td>3<td>2<sup>-3</sup><td>2<sup>-2</sup><td><a href="#2h">2<sup>h</sup></a><td>2<sup>-1</sup><td>
<tr><td>ε<td><a href="#3b">3<sup>b</sup></a><td>1<sup>-9</sup><td>1<sup>-8</sup><td>1<sup>-7</sup><td>1<sup>-6</sup><td><a href="#2b">2<sup>b</sup></a><td>1<sup>-5</sup><td><td>1<sup>+5</sup><td><td><td><td><td>1<sup>+6</sup><td><a href="#3e">3<sup>e</sup></a><td>1<sup>+7</sup><td>1<sup>+8</sup><td><td>1<sup>+9</sup><td>
<tr style="border-top: 3px solid #ccc">
<td>A<td>1<td>1<td>1<td>1<td>11=1<td>3<td>11=1<td>3<td>11=1<td>1<td>1<td>1<td>1<td>1<td>2<td>1<td>1<td>1<td>1<td>1
<tr>
<td>S<td>1<td><td><td><td><td><td>11=1<td><td><td>2<td>8=2<td>9=1<td>2<td><td><td><td><td>2<td><td>2
</table>

<p>Using two digit trunks for communication between accumulators makes some
sense given the instruction set. But there is no obvious advantage to doing so,
e.g. little happens in parallel on the two trunks. It would be simpler all
around if accumulators apart from the ft arguments transmitted and received on a
single trunk. At least, it would be nice if constants used a less contended
trunk, to permit using constant transceivers for dummy programs more often.

<<Digit trunks>>=
# Digit trunk connections

#  1    most accumulators transmit on 1
#  2    most accumulators receive on 2
#  3    ft argument
#  4    ft data A
#  5    ft data B
#  6,7  multiplier partial product digits (exclusive)
#  8=2  multiplier correction terms (shared)
p 8 2
#  9=1  multiplier correction terms (shared)
p 9 1
#  10   divider/square rooter answer (exclusive)
#  11=1 divider/square rooter shift (shared)
p 11 1

# Non-accumulator connections
<<Digit trunks: non-accumulator connections>>
# Accumulator connections
<<Digit trunks: accumulator connections>>
# Adapters
<<Digit trunks: adapters>>
@

<h4>Non-accumulator connections</h4>

<<Digit trunks: non-accumulator connections>>=
# Trunk 1 - accumulators, constants
p 1 c.o     # Constants for AB/CD/EF/GH/JK

# Trunk 2 - accumulators, instructions
p 2 os.o    # Instruction to decode, and immediate operand for NxD

# Trunk 3 - argument for F.T., PC
p 3 f1.arg
p 3 f2.arg
p 3 f3.arg

# Trunk 4 - ft data A
p 4 os.A    # Data for fetch and F.T.
p 4 f1.A
p 4 f2.A
p 4 f3.A

# Trunk 5 - ft data B
p 5 os.B    # Data for fetch and F.T.
p 5 f1.B
p 5 f2.B
p 5 f3.B

# Trunk 6/7 - multiplier partial products
p 6 m.lhppI
p 7 m.rhppI

# Trunk 10 - divider/square rooter answer
p 10 d.ans
@

<h4>Accumulator connections</h4>

<<Digit trunks: accumulator connections>>=
# Accumulator 1
p 2 a1.α
p 1 a1.β
p ad.permute.4 a1.δ  # 3(11,0s,10,9): 6(11,10,9)
p ad.permute.6 a1.ε  # 3(0s,8,7): 6(8,7)
p 1 a1.A
p 1 a1.S  # Save to a13
@ %def a1

<<Digit trunks: accumulator connections>>=
# Accumulator 2
p 2 a2.α
p 1 a2.β
p ad.permute.20 a2.δ  # Sh  01 answer
p ad.permute.30 a2.ε  # Sh' 01 residual
p 1 a2.A
@ %def a2

<<Digit trunks: accumulator connections>>=
# Accumulator 3
p 2 a3.α
p 1 a3.β
p ad.permute.21 a3.δ  # Sh  02 answer
p ad.permute.31 a3.ε  # Sh' 02 residual
p 1 a3.A
@ %def a3

<<Digit trunks: accumulator connections>>=
# Accumulator 4 - quotient
p 10 a4.α  # Divider/square rooter answer
p 2 a4.β
p 1 a4.γ
p ad.permute.22 a4.δ  # Sh  03 answer
p ad.permute.32 a4.ε  # Sh' 03 residual
p 1 a4.A
@ %def a4

<<Digit trunks: accumulator connections>>=
# Accumulator 5 - numerator
p 2 a5.α
p 11 a5.γ  # Divider shift (1=11)
p ad.permute.23 a5.δ  # Sh  04 answer
p ad.permute.33 a5.ε  # Sh' 04 residual
p 11 a5.A  # Divider shift (1=11)
@ %def a5

<<Digit trunks: accumulator connections>>=
# Accumulator 6 - PC
p 2 a6.α
p ad.permute.8  a6.β  # 1(3-1): 6R3
p ad.permute.10 a6.γ  # 1(6-1): 6R6, NxD6, C.T.
p ad.permute.3  a6.δ  # 2(11,2,1,0s): 6(11,10,9)
# NB ε is also used as a dummy for increment
p ad.permute.5  a6.ε  # 2(0,0,2,1,0s): 6(8,7)
p 3 a6.A
@ %def a6

<<Digit trunks: accumulator connections>>=
# Accumulator 7 - denominator
p 2 a7.α
p 1 a7.β
p 10 a7.γ  # Divider answer
p ad.permute.24 a7.δ  # Sh  05 answer
p ad.permute.34 a7.ε  # Sh' 05 residual
p 11 a7.A  # Divider shift (1=11)
p 11 a7.S  # Divider shift (1=11)
@ %def a7

<<Digit trunks: accumulator connections>>=
# Accumulator 8 - F.T. argument
p 2 a8.α
p 3 a8.A
# NB ε is used as a dummy for increment
@ %def a8

<<Digit trunks: accumulator connections>>=
# Accumulator 9 - shift
p ad.s.1.1 a9.α
p 2 a9.β
p 1 a9.γ
p ad.permute.29 a9.δ  # Sh  95 answer
p ad.permute.39 a9.ε  # Sh' 95 residual
p 11 a9.A  # Divider shift (1=11)
@ %def a9

<<Digit trunks: accumulator connections>>=
# Accumulator 10
p 2 a10.α
p ad.permute.7 a10.β  # 3(3-1): 6R3
p ad.permute.9 a10.γ  # 3(6-1): 6R6, C.T.
p 1 a10.A
p 2 a10.S  # Save to a13 and clear fields of a6
@ %def a10

<<Digit trunks: accumulator connections>>=
# Accumulator 11 - ier
p 2 a11.α
p ad.permute.1  a11.β  # F.T. data A
p ad.permute.12 a11.γ  # For DS
p 1 a11.δ
p 1 a11.A
p 8 a11.S  # Multiplier correction (8=2)
@ %def a11

<<Digit trunks: accumulator connections>>=
# Accumulator 12 - icand
p 2 a12.α
p 1 a12.β
p 1 a12.A
p 9 a12.S  # Multiplier correction (9=1)
@ %def a12

<<Digit trunks: accumulator connections>>=
# Accumulator 13 - LHPP
p 6 a13.α  # Multiplier partial product
p 8 a13.β  # Multiplier correction (8=2)
p 1 a13.γ
p 1 a13.A
p 2 a13.S  # Restore temporaries
@ %def a13

<<Digit trunks: accumulator connections>>=
# Accumulator 14
p 2 a14.α
p 1 a14.β
p ad.permute.28 a14.δ  # Sh  94 answer
p ad.permute.38 a14.ε  # Sh' 94 residual
p 1 a14.A
@ %def a14

<<Digit trunks: accumulator connections>>=
# Accumulator 15
p 7 a15.α  # Multiplier partial product
p 9 a15.β  # Multiplier correction (9=1)
p ad.permute.2 a15.γ  # F.T. data B
p 3 a15.δ  # For 8t
p ad.permute.11 a15.ε # For C.T.
p 2 a15.A
@ %def a15

<<Digit trunks: accumulator connections>>=
# Accumulator 16
p 2 a16.α
p 1 a16.β
p ad.permute.27 a16.δ  # Sh  93 answer
p ad.permute.37 a16.ε  # Sh' 93 residual
p 1 a16.A
@ %def a16

<<Digit trunks: accumulator connections>>=
# Accumulator 17
p 2 a17.α
p 1 a17.β 
p ad.permute.26 a17.δ  # Sh  92 answer
p ad.permute.36 a17.ε  # Sh' 92 residual
p 1 a17.A
@ %def a17


<<Digit trunks: accumulator connections>>=
# Accumulator 18
p 2 a18.α
p 1 a18.β
p ad.permute.13 a18.γ  # For N4D
p ad.permute.14 a18.δ  # For N6D
p 1 a18.A
p 2 a18.S  # Save to a13
@ %def a18

<<Digit trunks: accumulator connections>>=
# Accumulator 19
p 2 a19.α
p 1 a19.β
p ad.permute.25 a19.δ  # Sh  91 answer
p ad.permute.35 a19.ε  # Sh' 91 residual
p 1 a19.A
@ %def a19

<<Digit trunks: accumulator connections>>=
# Accumulator 20
p 2 a20.α
p 1 a20.β
p ad.permute.9 a20.γ  # For 6R6
p ad.permute.10 a20.δ  # For 6R6
p 1 a20.A
p 2 a20.S  # Save to a13
@ %def a20

<h4>Adapters</h4>

<p><b><a name="4s">4*</b>.  Shift function table output A digits to left.

<<Digit trunks: adapters>>=
# Function table output A, shifted to the left for F.T.
p 4 ad.permute.1
s ad.permute.1 11,6,5,4,3,2,1,0,0,0,0
@ %def ad.permute.1

<p><b><a name="5s">5*</a></b>.  Shift function table output B digits to left.

<<Digit trunks: adapters>>=
# Function table output B, shifted to the left for F.T.
p 5 ad.permute.2
s ad.permute.2 11,6,5,4,3,2,1,0,0,0,0
@ %def ad.permute.2

<p><b><a name="3a">3<sup>a</sup></a>, <a name="2a">2<sup>a</sup></a></b>.
Shift A<sub>15</sub>(11,2,1) to the top two digits and back for
<code>6(11,10,9)</code>.

<<Digit trunks: adapters>>=
# For 6(11,10,9).
p 2 ad.permute.3
s ad.permute.3 11,2,1,0,0,0,0,0,0,0,0
p 3 ad.permute.4
s ad.permute.4 11,0,0,0,0,0,0,0,0,10,9
@ %def ad.permute.3 ad.permute.4

<p><b><a name="3b">3<sup>b</sup></a>, <a name="2b">2<sup>b</sup></a></b>.
Shift A<sub>15</sub>(2,1) to positions 8,7 and back for <code>6(8,7)</code>.

<<Digit trunks: adapters>>=
# For 6(8,7).
p 2 ad.permute.5
s ad.permute.5 0,0,0,2,1,0,0,0,0,0,0
p 3 ad.permute.6
s ad.permute.6 0,0,0,0,0,0,0,0,0,8,7
@ %def ad.permute.5 ad.permute.6

<p><b><a name="3c">3<sup>c</sup></a>, <a name="1c">1<sup>c</sup></a></b>.
Select digits 3-1 of A<sub>6</sub> or A<sub>15</sub> for <code>6R3</code>.

<<Digit trunks: adapters>>=
# For 6R3.
p 3 ad.permute.7
s ad.permute.7 0,0,0,0,0,0,0,0,3,2,1
p 1 ad.permute.8
s ad.permute.8 0,0,0,0,0,0,0,0,3,2,1
@ %def ad.permute.7 ad.permute.8

<p><b><a name="3d">3<sup>d</sup></a>, <a name="1d">1<sup>d</sup></a></b>.
Select digits 6-1 of A<sub>6</sub> or A<sub>15</sub> for <code>6R6</code>.

<<Digit trunks: adapters>>=
# For 6R6.
p 3 ad.permute.9
s ad.permute.9 0,0,0,0,0,6,5,4,3,2,1
p 1 ad.permute.10
s ad.permute.10 0,0,0,0,0,6,5,4,3,2,1
@ %def ad.permute.9 ad.permute.10

<p><b><a name="3e">3<sup>e</sup></a></b>. Shift new PC digits from 6-4 to 3-1
for <code>C.T.</code>

<<Digit trunks: adapters>>=
# For C.T., shift digits 6-4 to position 3-1.
p 3 ad.permute.11
s ad.permute.11 0,0,0,0,0,0,0,0,6,5,4
@ %def ad.permute.11

<p><b><a name="1f">1<sup>f</sup></a></b>.  Drop sign for DS.

<<Digit trunks: adapters>>=
# Delete sign for DS
p 1 ad.permute.12
s ad.permute.12 0,10,9,8,7,6,5,4,3,2,1
@ %def ad.permute.12

<p><b><a name="2g">2<sup>g</sup></a>, <a name="2h">2<sup>h</sup></a></b>.
Shifts for <code>N4D</code> and <code>N6D</code> digits.

<<Digit trunks: adapters>>=
# Shift for N4D.
p 2 ad.permute.13
s ad.permute.13 0,0,0,0,0,0,0,2,1,0,0
# Shift for N6D.
p 2 ad.permute.14
s ad.permute.14 0,0,0,0,0,2,1,0,0,0,0
@ %def ad.permute.13 ad.permute.14

<p><b><a name="11s">11*</a></b>.  <tt>eniacsim</tt> requires this adapter for
its divider wiring.  ETM doesn't seem to mention it, so it's unclear if this is
a simulator quirk.

<<Digit trunks: adapters>>=
# For divider shifting
p 11 ad.s.1.1
@ %def ad.s.1.1

<p><b>1<sup>s</sup>, 2<sup>s</sup></b>.  <code>Sh</code> and <code>Sh'</code>
need a whole slew of adapters (<a href="#shifts">more discussion</a>.)

<<Digit trunks: adapters>>=
# Left shift adapters for Sh on a15.
p 2 ad.permute.20
s ad.permute.20 11,9,8,7,6,5,4,3,2,1,0       # << 1
p 2 ad.permute.21                            
s ad.permute.21 11,8,7,6,5,4,3,2,1,0,0       # << 2
p 2 ad.permute.22                            
s ad.permute.22 11,7,6,5,4,3,2,1,0,0,0       # << 3
p 2 ad.permute.23                            
s ad.permute.23 11,6,5,4,3,2,1,0,0,0,0       # << 4
p 2 ad.permute.24                            
s ad.permute.24 11,5,4,3,2,1,0,0,0,0,0       # << 5
# Right arithmetic shift adapters for Sh on a15.
p 2 ad.permute.25
s ad.permute.25 11,11,10,9,8,7,6,5,4,3,2     # >> 1
p 2 ad.permute.26
s ad.permute.26 11,11,11,10,9,8,7,6,5,4,3    # >> 2
p 2 ad.permute.27
s ad.permute.27 11,11,11,11,10,9,8,7,6,5,4   # >> 3
p 2 ad.permute.28
s ad.permute.28 11,11,11,11,11,10,9,8,7,6,5  # >> 4
p 2 ad.permute.29
s ad.permute.29 11,11,11,11,11,11,10,9,8,7,6 # >> 5
@ %def ad.permute.20 ad.permute.21 ad.permute.22 ad.permute.23 ad.permute.24 ad.permute.25 ad.permute.26 ad.permute.27 ad.permute.28 ad.permute.29

<<Digit trunks: adapters>>=
# Sh' opposite of left shifts.
p 1 ad.permute.30
s ad.permute.30 11,11,11,11,11,11,11,11,11,11,10  # >> 9
p 1 ad.permute.31
s ad.permute.31 11,11,11,11,11,11,11,11,11,10,9   # >> 8
p 1 ad.permute.32
s ad.permute.32 11,11,11,11,11,11,11,11,10,9,8    # >> 7
p 1 ad.permute.33
s ad.permute.33 11,11,11,11,11,11,11,10,9,8,7     # >> 6
p 1 ad.permute.34
s ad.permute.34 11,11,11,11,11,11,10,9,8,7,6      # >> 5
# Sh' opposite of right shifts.
p 1 ad.permute.35
s ad.permute.35 11,1,0,0,0,0,0,0,0,0,0            # << 9
p 1 ad.permute.36
s ad.permute.36 11,2,1,0,0,0,0,0,0,0,0            # << 8
p 1 ad.permute.37
s ad.permute.37 11,3,2,1,0,0,0,0,0,0,0            # << 7
p 1 ad.permute.38
s ad.permute.38 11,4,3,2,1,0,0,0,0,0,0            # << 6
p 1 ad.permute.39
s ad.permute.39 11,5,4,3,2,1,0,0,0,0,0            # << 5
@ %def ad.permute.30 ad.permute.31 ad.permute.32 ad.permute.33 ad.permute.34 ad.permute.35 ad.permute.36 ad.permute.37 ad.permute.38 ad.permute.39

<<Digit trunks: adapters>>=
# Special digit adapters
# E-8 is the third digit of a6 or a8 from trunk 3.
p 3 ad.dp.1.3
p ad.dp.1.3 E-8
# E-2 selects the ones digit of the order from trunk 2.
p 2 ad.dp.2.1
p ad.dp.2.1 E-2
# F-6 selects the tens digit of the order from trunk 2.
p 2 ad.dp.3.2
p ad.dp.3.2 F-6

# G-3 selects the sign of a15 from trunk 2 for C.T.
p 2 ad.dp.4.11
p ad.dp.4.11 G-3
@ %def E-8 E-2 F-6 G-3

<h3><a name=amps>Pulse amplifiers</a></h3>

<p>LCS48 Table 2.II illustrates how a tree of pulse amplifiers is used to
combine decode lines into common control signals. For example, all the
<code>xl</code> instructions share a sequence controlled by [[C-1]], with their
separate behavior controlled by individual decode lines.

<<Pulse amplifiers>>=
# Pulse amplifier connections

# Listen orders (xl) -> C-1
# Note that C-1 is also the encoding for 00 (C) which clears a15.
# 6l is not included because it cannot overlap with fetch.
p pa.1.sa.1  S-1  # 1l
p pa.1.sb.1  C-1
p pa.1.sa.2  S-2  # 2l
p pa.1.sb.2  C-1
p pa.1.sa.3  S-3  # 3l
p pa.1.sb.3  C-1
p pa.1.sa.4  S-4  # 4l
p pa.1.sb.4  C-1
p pa.1.sa.5  S-5  # 5l
p pa.1.sb.5  C-1
p pa.1.sa.6  S-6  # 7l
p pa.1.sb.6  C-1
p pa.1.sa.7  L-7  # 8l
p pa.1.sb.7  C-1
p pa.1.sa.8  L-8  # 9l
p pa.1.sb.8  C-1
p pa.1.sa.9  L-9  # 10l
p pa.1.sb.9  C-1
p pa.1.sa.10 L-10 # 11l
p pa.1.sb.10 C-1
p pa.1.sa.11 L-11 # 12l
p pa.1.sb.11 C-1
p pa.2.sa.1  C-7  # 13l
p pa.2.sb.1  C-1
p pa.2.sa.2  H-1  # 14l
p pa.2.sb.2  C-1
p pa.2.sa.3  H-2  # 16l
p pa.2.sb.3  C-1
p pa.2.sa.4  H-3  # 17l
p pa.2.sb.4  C-1
p pa.2.sa.5  H-4  # 18l
p pa.2.sb.5  C-1
p pa.2.sa.6  H-5  # 19l
p pa.2.sb.6  C-1
#p pa.x.sa.y  C-8  # 20l
#p pa.x.sb.y  C-1
@ %def C-1

<p>Table 2.II seems to mention e.g. <tt>U-9</tt>, but there is no other mention
of the <tt>U</tt> trunk.  From Table 2.I, it's pretty clear this ought to be
[[V-9]], so assume the script font here just has <tt>V</tt>s that look like
<tt>U</tt>s.

<<Pulse amplifiers>>=
# Talk orders (xt) -> D-3
# 6t and 8t are not included because a6 and a8 transmit on a separate
# trunk to address the function table.
p pa.2.sa.7  V-9  # 1t
p pa.2.sb.7  D-3
p pa.2.sa.8  S-7  # 2t
p pa.2.sb.8  D-3
p pa.2.sa.9  S-8  # 3t
p pa.2.sb.9  D-3
p pa.2.sa.10 S-9  # 4t
p pa.2.sb.10 D-3
p pa.2.sa.11 S-10 # 5t
p pa.2.sb.11 D-3
p pa.3.sa.1  S-11 # 7t
p pa.3.sb.1  D-3
p pa.3.sa.2  L-1  # 9t
p pa.3.sb.2  D-3
p pa.3.sa.3  L-2  # 10t
p pa.3.sb.3  D-3
p pa.3.sa.4  L-3  # 11t
p pa.3.sb.4  D-3
p pa.3.sa.5  L-4  # 12t
p pa.3.sb.5  D-3
p pa.3.sa.6  L-5  # 13t
p pa.3.sb.6  D-3
p pa.3.sa.7  L-6  # 14t
p pa.3.sb.7  D-3
p pa.3.sa.8  C-9  # 16t
p pa.3.sb.8  D-3
p pa.3.sa.9  H-6  # 17t
p pa.3.sb.9  D-3
p pa.3.sa.10 H-7  # 18t
p pa.3.sb.10 D-3
p pa.3.sa.11 H-8  # 19t
p pa.3.sb.11 D-3
#p pa.x.sa.y  H-9  # 20t
#p pa.x.sb.y  D-3
@ %def D-3

<<Pulse amplifiers>>=
# Constant transfers (const) -> D-4
p pa.4.sa.1  D-7  # AB
p pa.4.sb.1  D-4
p pa.4.sa.2  D-8  # CD
p pa.4.sb.2  D-4
p pa.4.sa.3  D-9  # EF
p pa.4.sb.3  D-4
p pa.4.sa.4  D-10 # GH
p pa.4.sb.4  D-4
p pa.4.sa.5  D-11 # JK
p pa.4.sb.5  D-4
@ %def D-4

<<Pulse amplifiers>>=
# Misc remaining 7 cycle ops (a1tmp) -> D-5
# These instructions use a1 as a temporary.
p pa.4.sa.6 V-2  # 6(11,10,9)
p pa.4.sb.6 D-5
p pa.4.sa.7 V-3  # M
p pa.4.sb.7 D-5
p pa.4.sa.8 V-4  # 6(8,7)
p pa.4.sb.8 D-5
@ %def D-5

<p>[[B-3]] triggers <tt>a15:β01</tt>, and [[B-4]] triggers <tt>a13:γ01</tt>.

<<Pulse amplifiers>>=
# Talk or constant transfers -> B-3
# B-3 triggers a15 to receive on trunk 1.
p pa.4.sa.9 D-3  # xt
p pa.4.sb.9 B-3
p pa.4.sa.10 D-4 # const
p pa.4.sb.10 B-3
# a1tmp instructions -> B-4.
# B-4 triggers a13 to receive on trunk 1.
p pa.5.sa.1 D-5  # a1tmp
p pa.5.sb.1 B-4
@

<p>[[J-3]] clears A<sub>11</sub> and then receives on trunk 1 for constant
instructions. <code>F.T.</code> operates on A<sub>11</sub> but needs to receive
shifted digits from the function table, not trunk 1. Even so, programs are tight
on A<sub>11</sub>, so just clearing and receiving nothing might have been useful
to share&mdash;we squeak by without.

<<Pulse amplifiers>>=
# J-3 clears accumulator 11, then receives it on trunk 1.
# It is used by constant transfers, and was probably reused by F.T.
# originally but is not in this implementation.
p pa.4.sa.11 D-4 # const
p pa.4.sb.11 J-3
@ %def J-3

<p>The most important common control signals are [[C-5]] and its
<q>duals</q> [[D-6]], [[J-2]], and [[E-1]], which control aspects of the
fetch and decode sequence.  7-cycle instructions re-assert [[C-5]] through
pulse amplifiers directly on decode.  Longer duration orders and transfers need
separate wiring to trigger [[C-5]].

<<Pulse amplifiers>>=
# C-5 triggers fetching _and decoding_ another instruction.
# C-1 (xl), D-3 (xt), D-4 (const), D-5 (a1tmp) as well as C-2 (8t), V-1 (6t in
# alternate code), and H-10 (DS) all do so immediately upon decode.
p pa.5.sa.2 C-1  # xl
p pa.5.sb.2 C-5
p pa.5.sa.3 D-3  # xt
p pa.5.sb.3 C-5
p pa.5.sa.4 D-4  # const
p pa.5.sb.4 C-5
p pa.5.sa.5 D-5  # a1tmp
p pa.5.sb.5 C-5
p pa.5.sa.6 C-2  # 8t
p pa.5.sb.6 C-5
#p pa.x.sa.y V-1 # 6t
#p pa.x.sb.y C-5
p pa.5.sa.7 H-10 # DS
p pa.5.sb.7 C-5
@ %def C-5

<p>Instructions with operands reuse the fetch sequence via [[D-6]] to retrieve
operands without decoding them as a new instruction.

<<Pulse amplifiers>>=
# D-6 triggers the fetch sequence separately from decode.
p pa.5.sa.11 C-5 # fetch+decode -> fetch
p pa.5.sb.11 D-6
p pa.5.sa.9 C-6  # N2D/N4D/N6D/N3D8 use fetch
p pa.5.sb.9 D-6
p pa.5.sa.10 D-2 # ...also fake N4D triggered from N6D
p pa.5.sb.10 D-6
p pa.5.sa.8 D-1  # ...also fake N2D triggered from N4D/N6D
p pa.5.sb.8 D-6
p pa.6.sa.1 C-11 # Sh/Sh' take a shift amount
p pa.6.sb.1 D-6
@ %def D-6

<p><code>F.T.</code> can assert [[E-1]] without [[J-2]] to use A<sub>8</sub> as
the ft argument.  But it's unclear when we would want to assert [[J-2]] without
[[E-1]]&mdash;perhaps to reuse <tt>a6:A01</tt> with a harmless side-effect?
Programs are tight on A<sub>6</sub> so this is certainly feasible.

<<Pulse amplifiers>>=
# J-2 and E-1 are duals of D-6
p pa.6.sa.2 D-6
p pa.6.sb.2 J-2  # send PC
p pa.6.sa.3 D-6
p pa.6.sb.3 E-1  # read FT
@ %def J-2 E-1

<p>Connections for <code>NxD</code> hint that these sequences are chained
together.  [[C-6]] triggers saving A<sub>18</sub> for the original decoded
instruction only; [[D-1]] and [[D-2]] are used to chain to sub-sequences
without the step done by [[C-6]].  <code>N2D</code> is the last step of the
chain and would restore A<sub>18</sub>.  (<code>N3D8</code> would have required
separate programming but is not implemented here.)

<<Pulse amplifiers>>=
# C-6 is {N2D,N4D,N6D,N3D8} - instructions that use a18 temporary.
p pa.6.sa.4 V-5  # N2D
p pa.6.sb.4 C-6
p pa.6.sa.5 V-7  # N6D
p pa.6.sb.5 C-6
#p pa.x.sa.y V-8 # N3D8
#p pa.x.sb.y C-6
p pa.6.sa.6 V-6  # N4D
p pa.6.sb.6 C-6

# D-1 is dual of N2D, also triggered by N4D sequence.
p pa.6.sa.7 V-5  # N2D
p pa.6.sb.7 D-1
# D-2 is dual of N4D, also triggered by N6D sequence.
p pa.6.sa.8 V-6  # N4D
p pa.6.sb.8 D-2
@ %def C-6 D-1 D-2

<<Pulse amplifiers>>=
# This connection is given in table 2.II without context.
# It's useful for the a1tmp sequence, so use it for that.
p pa.6.sa.9 C-4  # cycle 8 of a1tmp instructions
p pa.6.sb.9 J-1  # a15 send and clear

# Note C-11 is also the encoding for Sh.
p pa.6.sa.10 C-10 # Sh'
p pa.6.sb.10 C-11 # Sh

#p pa.x.sa.y C-8 # 20l
#p pa.x.sb.y K-11
@

<p>As helpful as LCS48 Table 2.II is, it's probably not comprehensive.  Pulse
amplifiers are so useful for conserving program inputs that it seems likely all
channels would have been used.  If we omit those for alternate instructions,
there are a luxurious 23 spare for this reconstruction.

<<Pulse amplifiers>>=
# Reset sequence
p pa.6.sa.11 A-1 # initiate pulse
p pa.6.sb.11 G-6 # clear order selector
p pa.7.sa.1  A-1 # initiate pulse
p pa.7.sb.1  E-9 # clear ft selector
@

<<Pulse amplifiers>>=
# a1tmp: Trigger a13 send
p pa.7.sa.2 T-8  # a1tmp+11
p pa.7.sb.2 B-11 # a13 send and clear
@

<<Pulse amplifiers>>=
# X: Trigger a15 to receive correction term
p pa.7.sa.3 M-2  # X+19
p pa.7.sb.3 B-3  # a15 receive correction term
# X: Trigger a15 to receive partial product
p pa.7.sa.4 M-3  # X+20
p pa.7.sa.4 B-11 # a13 send and clear
p pa.7.sa.5 M-3  # X+20
p pa.7.sb.5 B-3  # a15 receive lhpp
@

<<Pulse amplifiers>>=
# ÷: Save and restore lots of temporaries
p pa.7.sa.6 R-10
p pa.7.sb.6 J-1
p pa.7.sa.7 Q-6
p pa.7.sb.7 B-11
@

<<Pulse amplifiers>>=
# DS: Save temporary
p pa.7.sa.8 H-10
p pa.7.sb.8 B-4
@

<<Pulse amplifiers>>=
# Control flow ops share a common sequence K-1.
p pa.7.sa.9  E-6  # 6R3
p pa.7.sb.9  K-1
p pa.7.sa.10 E-7  # 6R6
p pa.7.sb.10 K-1
p pa.7.sa.11 G-2  # C.T.
p pa.7.sb.11 J-1  # a15 send and clear
p pa.8.sa.1 G-5   # C.T. taken is basically 6R6
p pa.8.sa.1 E-7   # 6R6
@

<<Pulse amplifiers>>=
# 18↔20: Save temporary
p pa.8.sa.2 C-3  # 18↔20
p pa.8.sb.2 B-3  # a15 receive
@

<<Pulse amplifiers>>=
# F.T.: Trigger F.T. read
p pa.8.sa.3 H-11  # F.T.
p pa.8.sb.3 E-1   # ft read
@

<h3>Instruction sequences</h3>

<<Instructions>>=
# Control sequences for each instruction, from decode until reasserting C-5
<<Instructions: xl>>
<<Instructions: xt>>
<<Instructions: constant>>
<<Instructions: a1-based>>
<<Instructions: multiply>>
<<Instructions: divsq>>
<<Instructions: DS>>
<<Instructions: NxD>>
<<Instructions: control flow>>
<<Instructions: 18↔20>>
<<Instructions: F.T.>>
<<Instructions: Pr.>>
<<Instructions: Rd.>>

# Reused programs on a13 and a15
<<Instructions: common programs>>
@

<h4><a name=common>Common programs</a></h4>

<p>To conserve programs on A<sub>15</sub> and A<sub>13</sub>, several programs
to send and receive those accumulators are commonly reused through dummy
programs and pulse amplifiers.

<<Instructions: common programs>>=
# J-1: Send a15 on trunk 1
p J-1 a15.1i
s a15.op1 A
s a15.cc1 C

# B-3: Receive a15 on trunk 1
p B-3 a15.2i
s a15.op2 β

# B-11: Send a13 on trunk 1 (additively)
p B-11 a13.6i
s a13.op6 A
s a13.cc6 C
s a13.rp6 1

# B-10: Send a13 on trunk 1 (subtractively)
p B-10 a13.8i
s a13.op8 S
s a13.cc8 C
s a13.rp8 1

# B-4: Receive a13 on trunk 1
p B-4 a13.3i
s a13.op3 γ
s a13.cc3 0
@ %def B-3 B-4 B-10 B-11 J-1

<h4><a name=xl>xl (and C)</a></h4>

<pre>
  7. aL:AC1           # Clear aL [1]
   * a13:001          # ... except a13
  8. a15:AC1, aL:α01  # Receive a15 [2]
</pre>

<p><code>C</code> is just <code>xl</code> with no accumulator transmitting to
replace the value in A<sub>15</sub>.

<<Instructions: xl>>=
# xl (and C)

# xl cycle 7: Clear aL
<<Instructions: xl cycle 7>>
# xl cycle 8: Receive from a15
<<Instructions: xl cycle 8>>
@

<<Instructions: xl cycle 7>>=
# Clear "listening" accumulator
# 1ℓ
p S-1 a1.5i
s a1.op5 A  # NB this is AC1 in Figure 3.3 not 0C1.
s a1.cc5 C
s a1.rp5 1
p a1.5o O-8  # O-8 is given in Figure 3.3.
# To conserve program lines, wire aN.5o directly to aN.1i for N>1.  In practice
# this would have been done with U cables (ETM XI-8).
# 2l
p S-2 a2.5i
s a2.op5 A
s a2.cc5 C
s a2.rp5 1
p a2.5o a2.1i
# 3l
p S-3 a3.5i
s a3.op5 A
s a3.cc5 C
s a3.rp5 1
p a3.5o a3.1i
# 4l
p S-4 a4.5i
s a4.op5 A
s a4.cc5 C
s a4.rp5 1
p a4.5o a4.1i
# 5l
p S-5 a5.5i
s a5.op5 A
s a5.cc5 C
s a5.rp5 1
p a5.5o a5.1i
# 6l = E-4 is not implemented
# 7l 
p S-6 a7.5i
s a7.op5 A
s a7.cc5 C
s a7.rp5 1
p a7.5o a7.1i
# 8l
p L-7 a8.5i
s a8.op5 A
s a8.cc5 C
s a8.rp5 1
p a8.5o a8.1i
# 9l
p L-8 a9.5i
s a9.op5 A
s a9.cc5 C
s a9.rp5 1
p a9.5o a9.1i
# 10l
p L-9 a10.5i
s a10.op5 A
s a10.cc5 C
s a10.rp5 1
p a10.5o a10.1i
# 11ℓ
p L-10 a11.5i
s a11.op5 A
s a11.cc5 C
s a11.rp5 1
p a11.5o a11.1i
# 12l
p L-11 a12.5i
s a12.op5 A
s a12.cc5 C
s a12.rp5 1
p a12.5o a12.1i
# 13l
# 13l does a13 += a15 rather than a13 = a15
# NOTE: We could move the dummy off a13.
p C-7 a13.5i
s a13.op5 0
s a13.cc5 0
s a13.rp5 1
p a13.5o a13.1i
# 14l
p H-1 a14.5i
s a14.op5 A
s a14.cc5 C
s a14.rp5 1
p a14.5o a14.1i
# 16l
p H-2 a16.5i
s a16.op5 A
s a16.cc5 C
s a16.rp5 1
p a16.5o a16.1i
# 17l
p H-3 a17.5i
s a17.op5 A
s a17.cc5 C
s a17.rp5 1
p a17.5o a17.1i
# 18l 
p H-4 a18.5i
s a18.op5 A
s a18.cc5 C
s a18.rp5 1
p a18.5o a18.1i
# 19l
p H-5 a19.5i
s a19.op5 A
s a19.cc5 C
s a19.rp5 1
p a19.5o a19.1i
# 20l = C-8 is not implemented

# Dummy to trigger J-1 in cycle 8
# This is wired as specified in figure 3.3.  Note that this causes contention
# on trunk 1 during cycle 7 since it conflicts with e.g. a1:AC1.
p C-1 c.3i
p c.3o J-1
@ %def O-8

<p>[[C-1]] from pulse amplifiers triggers the second, A<sub>15</sub> cycle of
<code>xl</code> which is the same for each listen instruction.

<<Instructions: xl cycle 8>>=
# J-1 triggers a15:AC1
# Receive from a15 on trunk 2
p O-8 a1.1i
s a1.op1 α
# aN.1i for N>1 is wired up directly in xl cycle 7
s a2.op1 α
s a3.op1 α
s a4.op1 β
s a5.op1 α
# 6l is not implemented
s a7.op1 α
s a8.op1 α
s a9.op1 β
s a10.op1 α
s a11.op1 α
s a12.op1 α
s a13.op1 β
s a14.op1 α
s a16.op1 α
s a17.op1 α
s a18.op1 α
s a19.op1 α
# 20l is not implemented
@

<h4><a name=xt>xt</a></h4>

<pre>
  7. aT:A01, a15:β01  # a15 receive aT
   * a13:AC1          # ... for a13 only, send and clear
</pre>
<p><code>8t</code> is a special case because <code>a8.A</code> is connected to
digit trunk 3 so needs a separate program on A<sub>15</sub>.

<<Instructions: xt>>=
# xt

# Cycle 7: a15 receive from aX
# D-3 -> B-3 triggers a15:β01
# Special case for 8t: a15 receive on trunk 3
p C-2 a15.3i
s a15.op3 δ

# 1t
p V-9 a1.2i
s a1.op2 A
# 2t
p S-7 a2.2i
s a2.op2 A
# 3t
p S-8 a3.2i
s a3.op2 A
# 4t
p S-9 a4.2i
s a4.op2 A
# 5t
p S-10 a5.2i
s a5.op2 A
# 6t = V-1 is not implemented
# 7t
p S-11 a7.2i
s a7.op2 A
# 8t
p C-2 a8.2i
s a8.op2 A
# 9t
p L-1 a9.2i
s a9.op2 A
# 10t
p L-2 a10.2i
s a10.op2 A
# 11t
p L-3 a11.2i
s a11.op2 A
# 12t
p L-4 a12.2i
s a12.op2 A
# 13t: Uniquely, 13t clears after sending
p L-5 a13.2i
s a13.op2 A
s a13.cc2 C
# 14t
p L-6 a14.2i
s a14.op2 A
# 16t
p C-9 a16.2i
s a16.op2 A
# 17t
p H-6 a17.2i
s a17.op2 A
# 18t
p H-7 a18.2i
s a18.op2 A
# 19t
p H-8 a19.2i
s a19.op2 A
@

<h4><a name="const">AB/CD/EF/GH/JK</a></h4>

<p><code>AB</code> is one of two instructions with a sequence chart in LCS48,
figure 3.2.  There is nothing very surprising.
<pre>
  7. Blr, a15:β01  # Receive B digits in a15 [1]
  8. Alr, a11:δ01  # Receive A digits in a11 [1]
</pre>

<<Instructions: constant>>=
# AB/CD/EF/GH/JK

# Constant cycle 7: right digits to a15
<<Instructions: constant cycle 7>>
# Constant cycle 8: left digits to a11
<<Instructions: constant cycle 8>>
@

<<Instructions: constant cycle 7>>=
# Transmit right digits.
p D-7 c.1i    # AB
s c.s1 Blr
p c.1o c.2i
p D-8 c.7i    # CD
s c.s7 Dlr
p c.7o c.8i
p D-9 c.13i   # EF
s c.s13 Flr
p c.13o c.14i
p D-10 c.19i  # GH
s c.s19 Hlr
p c.19o c.20i
p D-11 c.25i  # JK
s c.s25 Klr
p c.25o c.26i
# D-4 -> B-3 triggers a15:β01

# Clear a11 to receive a constant next cycle.
p J-3 a11.6i
s a11.op6 0
s a11.cc6 C
s a11.rp6 1
p a11.6o T-6
@ %def T-6

<<Instructions: constant cycle 8>>=
# Transmit left digits.
# c.2i, c.8i, ... are connected directly from c.1o, c.7o, etc.
s c.s2 Alr
s c.s8 Clr
s c.s14 Elr
s c.s20 Glr
s c.s26 Jlr
# Receive constant digits.
p T-6 a11.3i
s a11.op3 δ
@

<h4><a name=a1tmp>6(11,10,9) and 6(8,7) and M</a></h4>

<p><code>M</code> is grouped with the <code>6(...)</code> instructions via the
pulse amplifier connection [[D-5]], presumably because all use A<sub>1</sub>
inputs. We may infer they share most of the same sequence.

<p>The <code>6(...)</code> instructions are listed as 7 cycles in LCS48 but as
10 in DU49. They can overlap the fetch sequence in LCS48 at least.

<p><code>6(11,10,9)</code> was renamed <code>6<sub>1</sub></code> in DEC51, and
has the side-effect (1+13&rarr;1). <code>6(8,7)</code> was renamed
<code>6<sub>2</sub></code> and also has the side-effect (1+13&rarr;1). These
explicit annotations from DEC51 make sense of LCS48 section IV which mentions
A<sub>1</sub> without context and otherwise looks like a typo. <blockquote>Acc.
15(2,1) transmit-clear to Acc. 6(8,7). Acc. 6(8,7) transmit-hold to Acc. 1(2,1).
Then, Acc. 1(2,1) transmit-clear to Acc. 15(2,1)</blockquote>

<h5>Shared sequence</h5>

<p>Some care is needed to avoid contention with <tt>a6:εC1</tt> in cycle 11.
Assigning a trunk 2 input to <tt>a6.ε</tt> ensures cycle 11 of this sequence can
happen in parallel.

<p>Although trunk 1 and 2 are both free in cycle 7, cycle 7 and 8 can't happen
in parallel due to contention on <tt>a6</tt> and <tt>a1</tt>.

<pre>
  7. a1:AC1, a13:γ01 # Save a1 [1]
  8. a15:AC1, (...)  # Operate on a15 [2,2*]
  9. -
 10. (...), a15:β01  # Get result back in a15 [1]
 11. a13:AC1, a1:β01 # Restore a1. [1]
</pre>

<<Instructions: a1-based>>=
# 6(11,10,9), 6(8,7), and M
# These instructions use a1 as a temporary and share the same sequence.

# Cycle 7: Save a1 in a13 (using trunk 1)
<<Instructions: a1-based cycle 7>>
# Cycle 8: C-4 -> J-1; per-instruction work
# Cycle 9: per-instruction work
# Cycle 10: Receive answer on trunk 1
<<Instructions: a1-based cycle 10>>
# Cycle 11: Restore a1 from a13 (using trunk 1)
<<Instructions: a1-based cycle 11>>

# These are the steps that vary per instruction.
<<Instructions: 6(11,10,9)>>
<<Instructions: 6(8,7)>>
<<Instructions: M>>
@

<<Instructions: a1-based cycle 7>>=
# Transmit a1
p D-5 a1.6i
s a1.op6 A
s a1.cc6 C
s a1.rp6 1
p a1.6o C-4  # Trigger a15:AC1 in cycle 8
# NOTE: We could just trigger J-1 here instead, so C-4 -> J-1 isn't helping.
# D-5 -> B-4 triggers a13:γ01

# Await cycle 10
p D-5 a19.12i
s a19.op12 0
s a19.cc12 0
s a19.rp12 3
p a19.12o T-7
@ %def C-4 T-7

<<Instructions: a1-based cycle 10>>=
# Three instructions share this a15:β01 program, so just duplicate it rather
# than trying to use B-3.
p T-7 a15.5i
s a15.op5 β
s a15.cc5 0
s a15.rp5 1
p a15.5o T-8
@ %def T-8

<<Instructions: a1-based cycle 11>>=
# Transmit a13 (T-8 -> B-11)
# Receive a1
p T-8 a1.3i
s a1.op3 β
s a1.cc3 0
@ %def B-11

<h4><a name="611109">6(11,10,9)</a></h4>

<p>This instruction does double duty as a "listen" and a "talk" order.

<pre>
  7. (a1:AC1, a13:γ01) # Save a1 [1]
  8. (a15:AC1), a6:δ01 # Add a15(11,2,1) into a6(11,10,9) [2,2*]
  9. (a6:A01), a1:δ01  # Get a6(11,10,9) in a1(11,2,1) (* a6:A01 from [[J-4]]) [3,3*]
 10. a1:AC1, (a15:β01) # Get a1(11,2,1) back in a15(11,2,1). [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: 6(11,10,9)>>=
# 6(11,10,9)

# Cycle 7: Dummy to delay V-2
p V-2 a2.6i
s a2.op6 0
s a2.cc6 0
s a2.rp6 1
p a2.6o T-1

# Cycle 8: Add a15(11,2,1) to a6(11,10,9)
p T-1 a6.7i
s a6.op7 δ
s a6.cc7 0
s a6.rp7 1
p a6.7o T-2

# Cycle 9: Receive 6(11,10,9) in 1(11,2,1)
# Fetch J-4 will send a6 this cycle.
p T-2 a1.7i
s a1.op7 δ
s a1.cc7 0
s a1.rp7 1
p a1.7o T-3

# Cycle 10: Transmit a1
# a15:β01 is part of common a1tmp sequence
p T-3 a1.8i
s a1.op8 A
s a1.cc8 C
s a1.rp8 1
@ %def T-1 T-2 T-3

<h4><a name="687">6(8,7)</a></h4>

<p>This instruction does double duty as a "listen" and a "talk" order.

<pre>
  7. (a1:AC1, a13:γ01) # Save a1 [1]
  8. (a15:AC1), a6:ε01 # Add 15(2,1) into 6(8,7) [2,2*]
  9. (a6:A01), a1:ε01  # Get 6(8,7) in 1(2,1) (* a6:A01 from [[J-4]]) [3,3*]
 10. a1:AC1, (a15:β01) # Get 1(2,1) back in 15(2,1). [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: 6(8,7)>>=
# 6(8,7)

# Cycle 7: Dummy to delay V-4
p V-4 a3.6i
s a3.op6 0
s a3.cc6 0
s a3.rp6 1
p a3.6o T-9

# Cycle 8: Add a15(2,1) to a6(8,7)
p T-9 a6.8i
s a6.op8 ε
s a6.cc8 0
s a6.rp8 1
p a6.8o T-10

# Cycle 9: Receive 6(8,7) in 1(2,1)
# Fetch J-4 will send a6 this cycle.
p T-10 a1.9i
s a1.op9 ε
s a1.cc9 0
s a1.rp9 1
p a1.9o T-11

# Cycle 10: Transmit a1
# a15:β01 is part of common a1tmp sequence
p T-11 a1.10i
s a1.op10 A
s a1.cc10 C
s a1.rp10 1
@ %def T-9 T-10 T-11

<h4><a name=m>M</a></h4>

<p>Complement the number in A<sub>15</sub> in 7 cycles.  DU49 and DEC51 have
this as 8 cycles, and DEC51 implies it uses A<sub>1</sub> (1+13&rarr;1).  This
suggests a sequence like
<pre>
  7. (a1:AC1, a13:γ01) # Save a1. [1]
  8. (a15:AC1), a1:α01 # a1 get a15 to be complemented. [2]
  9. -                 # (to reuse 6(11,10,9), 6(8,7) sequence)
 10. a1:SC1, (a15:β01) # a1 send complement of a15. [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: M>>=
# Cycle 7: Dummy to delay V-3
p V-3 a16.6i
s a16.op6 0
s a16.cc6 0
s a16.rp6 1
p a16.6o T-4

# Cycle 8: a1 gets a15
p T-4 a1.11i
s a1.op11 α
s a1.cc11 0
s a1.rp11 1
# Await cycle 9.
p T-4 c.4i
p c.4o c.5i

# Cycle 9: nop
# Await cycle 10.
p c.5o T-5

# Cycle 10: Transmit a1 subtractively
# a15:β01 is part of common a1tmp sequence
p T-5 a1.4i
s a1.op4 S
s a1.cc4 C
@ %def T-4 T-5

<p>This is roundabout, and could be simpler if accumulator inputs and outputs
weren't <a href="#trunks">crosswired</a>, since then we could just say
<pre>
  7. a15:AC1, a13:β01  # receive a15
  8. a13:SC1, a15:β01  # send -a15
</pre>

<h4><a name="multiply">X</a></h4>

<p>LCS48 claims <code>X</code> takes 15 cycles, but the multiplier needs 14
cycles and fetch takes 7 cycles.  DU49 claims a more honest 20 cycles with its
6 cycle fetch.

<p>The static accumulator wiring given in LCS48 is different to the canonical
wiring in ETM, with different accumulator assignments.  Probably the physical
layout of the machine's units had changed slightly in its 1948 installation.

<pre>
  7. a12:0C1, m.1i       # Start multiplication immediately
  8. a15:AC1, (a12:α01)  # Multiplier triggers a12:α01 [1]
  &vellip;
  21. (fetch)
</pre>

<<Instructions: multiply>>=
# Multiply

# Cycle 7: Start multiplication and clear icand
<<Instructions: multiply cycle 7>>
# Cycle 8: Transmit icand
# Cycle 9..18: (multiply)
# Cycle 19: Add correction terms for signed arguments
<<Instructions: multiply cycle 19>>
# Cycle 20: Combine partial products into a15
<<Instructions: multiply cycle 20>>
@

<<Instructions: multiply cycle 7>>=
# Start multiplication
p E-5 m.1i
# Clear icand
p E-5 a12.6i
s a12.op6 0
s a12.cc6 C
s a12.rp6 1
@

<<Instructions: multiply cycle 8>>=
# Trigger J-1 to transmit a15 to icand.
p m.Dα J-1
@

<<Instructions: multiply cycle 19>>=
# Apply correction from ier in lhpp
p m.RS M-1
p M-1 a11.4i
s a11.op4 S
p M-1 a13.4i
s a13.op4 β

# Apply correction from icand in rhpp
p m.DS M-2
p M-2 a12.3i
s a12.op3 S
# Pulse amplifiers trigger a15:β01 (M-2 -> B-3)
@ %def M-1 M-2

<<Instructions: multiply cycle 20>>=
# Finalize multiplication and retrigger fetch
p m.F M-3
# Pulse amplifiers trigger a13:AC1 (M-3 -> B-11)
# Pulse amplifiers trigger a15:β01 (M-3 -> B-3)
p m.1o C-5  # Retrigger fetch sequence
@ %def M-3

<<Instructions: multiply configuration>>=
# The static multiplier wiring is set up for ier=a11 and icand=a12
p m.ier a11
p m.icand a12
p m.L a13
p m.R a15
s m.ieracc1 0
s m.iercl1 0
s m.icandacc1 α  # Trigger a12:α01 in cycle 8
s m.icandcl1 0
s m.sf1 off
s m.place1 10
s m.prod1 0
@

<h4><a name="divsq">÷ and √</h4>

<p>Division and square rooting use A<sub>4/7</sub> and A<sub>9</sub>. As a
convenience, the instructions save and restore the values in those
accumulators&mdash;although since they take 100+ cycles, it might have been ok
to let programs deal with this instead.

<p>We could factor out shared sequences for saving and restoring accumulators,
but doing so isn't necessarily more efficient than duplicating programming
steps. Using a shared sequence would require adding dummy programs to continue
afterwards, so for example, a step like <tt>a15:AC1, a9:γ01</tt> needs four
programs whether it's shared or not. On balance, we just share a sequence to
save the accumulators.

<<Instructions: divsq>>=
# Divide and square root

# Accumulator wiring
p d.quotient a4
p d.numerator a5
p d.denominator a7
p d.shift a9

# Common to divide and square root
<<Instructions: divsq save>>

# Per-instruction sequences
<<Instructions: divide>>
<<Instructions: square root>>
@

<h5>Save sequence</h5>

<p>The save sequence begins in cycle 9, triggered by program outputs from cycle
8 in each instruction.  It shares two programs, one pulse amplifier, and one
constant transmitter dummy at the cost of two dummy programs.  Without this
sequence, we'd still need two non-constant transmitter dummy programs or two
pulse amplifiers to trigger <tt>a15:AC1</tt> from cycle 8, so on net this saves
a pulse amplifier or a few programs.

<<Instructions: divsq save>>=
# Save temporaries for div/sq

# Cycle 9: Transfer a15 to a5
<<Instructions: divsq save cycle 9>>
# Cycle 10: Save a9 in a15
<<Instructions: divsq save cycle 10>>
@

<h5>Save cycle 9</h5>

<<Instructions: divsq save cycle 9>>=
# R-10 -> J-1 triggers a15:AC1
# Receive a15 in a5 (trunk 2)
p R-10 a5.6i
s a5.op6 α
s a5.cc6 0
s a5.rp6 1
p a5.6o R-11
# Trigger a15:β01 in cycle 10
p R-10 c.6i
p c.6o B-3
@ %def R-10 R-11

<h5>Save cycle 10</h5>

<<Instructions: divsq save cycle 10>>=
# Save a9 to a15
p R-2 a9.3i
s a9.op6 A
s a9.cc6 C
# B-3 triggers a15:β01
@

<h4><a name="div">÷</h4>

<p>A<sub>4</sub> (quotient) and A<sub>9</sub> (shifter) are saved in
A<sub>13</sub> and A<sub>15</sub>, respectively, since DEC51 has side-effect
(4+13&rarr;4).

<pre>
  7. a5:0C1             # Clear a5
  8. a4:AC1, a13:γ01    # Save a4 in a13 [1]
  9. (a15:AC1, a5:α01)  # Transfer a15 to numerator [2]
 10. (a9:AC1, a15:β01)  # Save a9 in a15 [1]
 11. d.1i
 &vellip;
 x0. a9:0C1             # Clear a9
 x1. a15:AC1, a9:β01    # Restore a9 [2]
 x2. a4:AC1, a15:β01    # Get quotient in a15 [1]
 x3. a13:AC1, a4:β01    # Restore a4 [1]
 x4. (fetch)
</pre>

<<Instructions: divide>>=
# Divide
<<Instructions: divide configuration>>

# Cycle 7: Clear a5
<<Instructions: divide cycle 7>>
# Cycle 8-10: Save args
<<Instructions: divide cycle 8-10>>
# Cycle 11+: Divide
<<Instructions: divide cycle 11>>
# Cycle x0-x1: Restore sequence
<<Instructions: divide cycle x0-x1>>
# Cycle x2: Get quotient in a15
<<Instructions: divide cycle x2>>
# Cycle x3: Restore a4
<<Instructions: divide cycle x3>>
@

<h5>Divide cycle 7</h5>

<p>RIF has [[E-3]] trigger [[V-10]] via <tt>i.Ci2</tt>, but we'll use a
constant transceiver dummy instead since trunk 1 is free here and the SC
transceiver can be used when it is not.

<<Instructions: divide cycle 7>>=
# Clear a5
p E-3 a5.7i
s a5.op7 0
s a5.cc7 C
s a5.rp7 1
p a5.7o Q-1
# Trigger a13:γ01 in cycle 8
p E-3 c.9i
p c.9o B-4
@ %def Q-1

<h5>Divide cycle 8-10</h5>

<<Instructions: divide cycle 8-10>>=
# Cycle 8: Save a4 in a13
# Transmit a4
p Q-1 a4.6i
s a4.op6 A
s a4.cc6 C
s a4.rp6 1
p a4.6o R-10  # Trigger save sequence in cycles 9+10
# B-4 triggers a13:γ01 this cycle 

# Await cycle 11
p Q-1 a1.12i
s a1.op12 0
s a1.cc12 0
s a1.rp12 3
p a1.12o Q-2
@ %def Q-2

<h5>Divide cycle 11</h5>

<<Instructions: divide cycle 11>>=
# Start division
p Q-2 d.1i
# Finish division
p d.1o Q-3
@ %def Q-3

<h5>Divide cycle x0-x1</h5>

<<Instructions: divide cycle x0-x1>>=
# Cycle x0: Clear a9
p Q-3 a9.6i
s a9.op6 0
s a9.cc6 C
s a9.rp6 1
p a9.6o Q-4
# Trigger a15:AC1 in cycle x1.
p Q-3 c.10i
p c.10o J-1

# Cycle x1: Restore a9 from a15
# J-1 triggers a15:AC1
# Receive a9 (trunk 2)
p Q-4 a9.7i
s a9.op7 β
s a9.cc7 0
s a9.rp7 1
p a9.7o Q-5
# Trigger a15:β01 in cycle x2.
p Q-4 c.11i
p c.11o B-3
@ %def Q-4 Q-5

<h5>Divide cycle x2</h5>

<<Instructions: divide cycle x2>>=
# Transmit a4 (quotient) to a15
p Q-5 a4.7i
s a4.op7 A
s a4.cc7 C
s a4.rp7 1
p a4.7o Q-6
# B-3 triggers a15:β01.
@ %def Q-6

<h5>Divide cycle x3</h5>

<<Instructions: divide cycle x3>>=
# Restore a4 from a13
p Q-6 a4.8i
s a4.op8 β
s a4.cc8 0
s a4.rp8 1
p a4.8o C-5  # Trigger fetch sequence
# Q-6 -> B-11 triggers a13:AC1
@

<h5>Divide configuration</h5>

<<Instructions: divide configuration>>=
# Use divider input 1, transmitting arguments via external programs not
# divider-generated pulses due to the need to shuffle accumulators.
s d.nr1 0
s d.nc1 0
s d.dr1 0
s d.dc1 0
s d.pl1 D10
s d.ro1 RO
s d.an1 1
s d.il1 NI
@

<h4><a name=sqrt>√</a></h4>

<p>For <code>√</code>, A<sub>7</sub> (2&times;root) and A<sub>9</sub> (shifter)
aren't mentioned as mutated, so save those in A<sub>13</sub> and
A<sub>15</sub>, respectively (7+13&rarr;7).

<pre>
  7. a5:0C1             # Clear a5
  8. a7:AC1, a13:γ01    # Save a7 in a13 [1]
  9. (a15:AC1, a5:α01)  # Transfer a15 to argument [2]
 10. (a9:AC1, a15:β01)  # Save a9 in a15 [1]
 11. d.2i
  &vellip;
 x0. a9:0C1             # Clear a9
 x1. a15:AC1, a9:β01    # Restore a9 [2]
 x2. a7:AC5, a15:β05    # Note repeat 5: get 10*root in a15 [1]
 x7. a13:AC1, a7:β01    # Restore a7 [1]
</pre>

<<Instructions: square root>>=
# Square root
<<Instructions: square root configuration>>

# Cycle 7: Clear a5
<<Instructions: square root cycle 7>>
# Cycle 8-10: Save args
<<Instructions: square root cycle 8-10>>
# Cycle 11+: Square root
<<Instructions: square root cycle 11+>>
# Cycle x0-x1: Restore sequence
<<Instructions: square root cycle x0-x1>>
# Cycle x2: Get quotient in a15
<<Instructions: square root cycle x2>>
# Cycle x3: Restore a4
<<Instructions: square root cycle x7>>
@

<h5>Square root cycle 7</h5>

<<Instructions: square root cycle 7>>=
# Clear a5
p B-1 a5.8i
s a5.op8 0
s a5.cc8 C
s a5.rp8 1
p a5.8o R-1
# Trigger a13:γ01 in cycle 8
p B-1 c.12i
p c.12o B-4
@ %def R-1

<h5>Square root cycle 8-10</h5>

<<Instructions: square root cycle 8-10>>=
# Cycle 8: Save a7 in a13
# Transmit a7
p R-1 a7.6i
s a7.op6 A
s a7.cc6 C
s a7.rp6 1
p a7.6o R-10  # Trigger save sequence in cycles 9+10
# B-4 triggers a13:γ01 this cycle 

# Await cycle 11
p R-1 a2.11i
s a2.op11 0
s a2.cc11 0
s a2.rp11 3
p a2.11o R-2
@ %def R-2

<h5>Square root cycle 11+</h5>

<<Instructions: square root cycle 11+>>=
# Start square root
p R-2 d.2i
# Finish square root
p d.2o R-3
@ %def R-3

<h5>Square root cycle x0-x1</h5>

<<Instructions: square root cycle x0-x1>>=
# Cycle x0: Clear a9
p R-3 a9.8i
s a9.op8 0
s a9.cc8 C
s a9.rp8 1
p a9.8o R-4
# Trigger a15:AC1 in cycle x1.
p R-3 c.16i
p c.16o J-1

# Cycle x1: Restore a9 from a15
# J-1 triggers a15:AC1
p R-4 a9.9i
s a9.op9 β
s a9.cc9 0
s a9.rp9 1
p a9.9o R-5
@ %def R-4 R-5

<h5>Square root cycle x2</h5>

<p>The 5x reception requires dedicated repeat programs on A<sub>15</sub> and
A<sub>7</sub>.  This gives us a convenient way to trigger [[B-11]] in cycle x7
without using a pulse amplifier.

<<Instructions: square root cycle x2>>=
# Transmit 5 * (2*root) to a15.
p R-5 a7.7i
s a7.op7 A
s a7.cc7 C
s a7.rp7 5
p a7.7o R-6
p R-5 a15.6i
s a15.op6 β
s a15.cc6 0
s a15.rp6 5
p a15.6o B-11  # Trigger a13:AC1 next cycle
@ %def R-6

<h5>Square root cycle x7</h5>

<<Instructions: square root cycle x7>>=
# Restore saved a7 from a13
# B-11 triggers a13:AC1
p R-6 a7.8i
s a7.op8 β
s a7.cc8 0
s a7.rp8 1
p a7.8o C-5  # Trigger fetch sequence
@

<<Instructions: square root configuration>>=
# Due to the need to shuffle arguments to temporaries, use external programs to
# setup argument.
s d.nr2 0
s d.nc2 0
s d.dr2 0
s d.dc2 0
s d.pl2 R10
s d.ro2 RO
s d.an2 4
s d.il2 NI
s d.da A
s d.ra A
@

<h4><a name=ds>DS</a></h4>

<p>Drop sign of A<sub>15</sub> in 7 cycles.  DEC51 implies this uses
A<sub>11</sub> (11+13&rarr;11), like
<pre>
  7. a11:AC1, a13:γ01  # Save a11. [1]
  8. a15:AC1, a11:γ01  # Transmit a15, dropping sign. [2,2*]
  9. a11:AC1, a15:β01  # Get a15 without sign. [1]
 10. a13:AC1, a11:β01  # Restore a11. [1]
</pre>

<<Instructions: DS>>=
# DS

# Cycle 7: Save a11
<<Instructions: DS cycle 7>>
# Cycle 8: Transmit a15, dropping sign [trunk 2]
<<Instructions: DS cycle 8>>
# Cycle 9: Get a15 without sign.
<<Instructions: DS cycle 9>>
# Cycle 10: Restore a11
<<Instructions: DS cycle 10>>
@

<<Instructions: DS cycle 7>>=
# Transmit a11 on trunk 1
p H-10 a11.7i
s a11.op7 A
s a11.cc7 C
s a11.rp7 1
p a11.7o R-7
# H-10 -> B-4 triggers a13:γ01 via pulse amplifiers

# Trigger a15:AC1 in cycle 8
p H-10 a2.10i
s a2.op10 0
s a2.cc10 0
s a2.rp10 1
p a2.10o J-1
@ %def R-7

<<Instructions: DS cycle 8>>=
# Dummy from cycle 7 triggers a15:AC1
# Receive a15 in a11 without sign on trunk 2
p R-7 a11.8i
s a11.op8 γ
s a11.cc8 0
s a11.rp8 1
p a11.8o R-8
# Trigger a15:β01 in cycle 9.
p R-7 c.17i
p c.17o B-3
@ %def R-8

<<Instructions: DS cycle 9>>=
# Transmit a11 on trunk 1.
p R-8 a11.9i
s a11.op9 A
s a11.cc9 C
s a11.rp9 1
p a11.9o R-9
# B-3 triggers a15:β01

# Trigger a13:AC1 in cycle 10
p R-8 a2.9i
s a2.op9 0
s a2.cc9 0
s a2.rp9 1
p a2.9o B-11
@

<<Instructions: DS cycle 10>>=
# B-11 triggers a13:AC1
# Receive a11 on trunk 1.
p R-9 a11.10i
s a11.op10 β
s a11.cc10 0
s a11.rp10 1
@

<h4>NxD (N6D, N4D, N2D)</h4>

<p>LCS48 claims 14/20/26 cycles for <code>N2D</code> / <code>N4D</code> /
<code>N6D</code>, i.e. 7 cycles plus 6 per pair of digits with one extra cycle
for <code>N2D</code>; DU49 and DEC51 pad this out by two cycles to 15/21/27
cycles with a 6 cycle fetch.  DEC51 implies using A<sub>18</sub> subtractively
(18-13&rarr;18), e.g.
<pre>
  a18:SC1, a13:β01  # Save -a18 (e.g. a18.A=1 and a18.S=2) [2]
  &vellip;
  a18:γ01           # Load and shift ft data [2]
  a18:AC1, a15:β01  # Add ft data into a15 [1]
  a13:SC1, a18:α01  # Restore -(a13-a18) = a18-a13 [2]
</pre>

<p>The LCS48 timing seems plausible even with DEC51's implied sequence.
<code>N(x+1)D</code> can do its thing and then reuse <code>NxD</code>
programming.  We can save cycles shuffling accumulators if we place the
necessary shifters on a single accumulator, so suppose A<sub>18</sub> has both
the +4 input for <code>N6D</code> and the +2 input for <code>N4D</code>.

<<Instructions: NxD>>=
# NxD (N6D, N4D, N2D)

# Common to all instructions
# Cycle 7: Fetch operand, save -a18 if triggered from decode.
# Pulse amplifiers assert D-6 to fetch the operand.
# Transmit -a18
p C-6 a18.2i
s a18.op2 S
s a18.cc2 C
# Receive -a18 in a13
# Use a program on a13 directly since it is shared by three instructions.
# NOTE: In a pinch this could reuse a13.1i.
p C-6 a13.7i
s a13.op7 β
s a13.cc7 0
s a13.rp7 1

# Per instruction sequences
<<Instructions: N6D>>
<<Instructions: N4D>>
<<Instructions: N2D>>
@

<h4>N6D</h4>

<p>This sequence accumulates into A<sub>18</sub>, and relies on
<code>N2D</code> to transfer the result to A<sub>15</sub>.

<pre>
    7. ([[D-6]]),             # Read operand
       (a18:SC1, a13:β01) # Save -a18 [2]
    &vellip;
   12. ([[G-8]]), a18:δ01     # Receive +4 shifted digits at a18. [2,2(+4)]
   13. [[D-2]]                # Trigger N4D sequence
    &vellip;
   26. ([[C-5]])
</pre>

<<Instructions: N6D>>=
# N6D

# Cycle 7: Await operand
p V-7 a3.12i  # N6D
s a3.op12 0
s a3.cc12 0
s a3.rp12 5
p a3.12o N-1

# Cycle 12: Receive +4 shifted operand at a18 (trunk 2)
# Receive a18
p N-1 a18.6i
s a18.op6 δ
s a18.cc6 0
s a18.rp6 1
p a18.6o D-2  # N4D'

# Cycle 13-26: Chain to N4D/N2D
@ %def N-1

<h4>N4D</h4>

<p>This sequence accumulates into A<sub>18</sub>, and relies on
<code>N2D</code> to transfer the result to A<sub>15</sub>.

<pre>
    7. ([[D-6]]),              # Read operand
       (a18:SC1, a13:β01)* # Save -a18 (*unless N6D) [2]
    &vellip;
   12. ([[G-8]]), a18:γ01      # Receive +2 shifted digits at a18 [2,2+2]
   13. [[D-1]]                 # Trigger N2D sequence
    &vellip;
   20. ([[C-5]])
</pre>

<<Instructions: N4D>>=
# N4D 

# Cycle 7: Await operand
p D-2 a3.11i  # N4D'
s a3.op11 0
s a3.cc11 0
s a3.rp11 5
p a3.11o N-2

# Cycle 12: Receive +2 shifted operand at a18 (trunk 2)
# Receive a18
p N-2 a18.7i
s a18.op7 γ
s a18.cc7 0
s a18.rp7 1
p a18.7o D-1  # N2D'

# Cycle 13-20: Chain to N2D
@ %def N-2

<h4>N2D</h4>

<p><code>N2D</code> could go faster if the order selector transmitted on trunk
1, since it could then receive the operand directly at A<sub>15</sub>. But
because its sequence is reused from <code>N6D/N4D</code>, it has to accumulate
into A<sub>18</sub> anyway.

<p>[[C-5]] could plausibly be re-asserted earlier, but this timing matches
LCS48.

<pre>
    7. ([[D-6]]),              # Read operand
       (a18:SC1, a13:β01)* # Save -a18 (*unless N4D/N6D) [2]
    &vellip;
   12. ([[G-8]]), a18:α01      # Receive digits at a18 [2]
   13. a18:AC1, a15:β01    # Send immediate digits to a15 [1]
   14. a13:SC1, a18:α01,   # Restore -(a13-a18) = a18-a13 [2]
       [[C-5]],                # Fetch and decode next instruction
</pre>

<<Instructions: N2D>>=
# N2D

# Cycle 7: Await operand
<<Instructions: N2D cycle 7>>
# Cycle 12: Receive operand at a18 (trunk 2)
<<Instructions: N2D cycle 12>>
# Cycle 13: Send immediate digits to a15
<<Instructions: N2D cycle 13>>
# Cycle 14: Restore a18 from a13 (trunk 2)
<<Instructions: N2D cycle 14>>
@

<h5>N2D cycle 7</h5>

<<Instructions: N2D cycle 7>>=
# Await operand
p D-1 a3.10i  # N2D'
s a3.op10 0
s a3.cc10 0
s a3.rp10 5
p a3.10o N-3
@ %def N-3

<h5>N2D cycle 12</h5>

<<Instructions: N2D cycle 12>>=
# Receive a18
p N-3 a18.8i
s a18.op8 α
s a18.cc8 0
s a18.rp8 1
p a18.8o N-4

# Dummy to trigger a15:β01 in cycle 13
p N-3 c.15i
p c.15o B-3
@ %def N-4

<h5>N2D cycle 13</h5>

<<Instructions: N2D cycle 13>>=
# Transmit a18
p N-4 a18.9i
s a18.op9 A
s a18.cc9 C
s a18.rp9 1
p a18.9o N-5
# B-3 triggers a15:β01

# Dummy to trigger a13:SC1 in cycle 14
p N-4 i.Ci2
p i.Co2 B-10
# Dummy to trigger C-5 in cycle 14
p N-4 a3.9i
s a3.op9 0
s a3.cc9 0
s a3.rp9 1
p a3.9o C-5
@ %def N-5

<h5>N2D cycle 14</h5>

<<Instructions: N2D cycle 14>>=
# B-10 triggers a13:SC1
# Receive a18
p N-5 a18.4i
s a18.op4 α
s a18.cc4 0
@

<h4><a name="cflow">Control flow</a></h4>

<<Instructions: control flow>>=
# Control flow (6R3, 6R6 and C.T.)

# These instructions mostly share the same sequence.
<<Instructions: control flow common>>

# Per-instruction sequences
<<Instructions: 6R3>>
<<Instructions: 6R6>>
<<Instructions: C.T.>>
@

<p>All sources list <code>6R3</code> and <code>6R6</code> at 13 cycles, and
<code>C.T.</code> at 14 cycles for taken and 8 cycles for not-taken branches.
These cycle counts should be reliable because the next fetch is dependent. But
with an obvious datapath, these instructions would run 1-2 cycles
<em>faster</em> than specified.

<h5>Obvious datapath</h5>

<p>An obvious datapath for e.g. <code>6R3</code> would use two inputs for
<code>3(11-4)</code> and <code>2(3-1)</code> on A<sub>10</sub>, and one trunk 1
input on A<sub>6</sub> to accumulate the desired fields into A<sub>10</sub> in
four cycles.

<pre>
  # Notional 6R3 sequence
  7. a10:SC1, a13:β01  # Save -a10 [2]
  8. a6:AC1, a10:β01   # Isolate a6(11-4) [3,3(11-4)]
  9. a15:AC1, a10:γ01  # Add a15(3-1) [2,2(3-1)]
 10. a10:AC1, a6:β01   # Set new PC [1]
 11. a13:SC1, a10:α01  # Restore -a10 [2]
 12. [[C-5]]
</pre>

<p>This leaves enough inputs on A<sub>6</sub> for <code>6l</code>,
<code>6(11,10,9)</code> and <code>6(8,7)</code>. <code>NxD6</code> would reuse
the A<sub>6</sub> trunk 1 input along with two additional inputs on
A<sub>18</sub> to clear components of A<sub>6</sub> and add back immediate
operand digits:

<pre>
  # Notional NxD6 sequence
  7. (save and clear a18)
  8. a6:AC1, a18:[βε]01  # Receive a6(11-4) [3,3*]
                         #      or a6(11-6)
  &vellip;
  n. a18:AC1, a6:β01     # Get immediate operand digits [1]
</pre>

<p>However, this datapath would require two inputs each on the temporary
accumulators for <code>6Rx</code>. Since <code>C.T.</code> also requires an
input, the three instructions couldn't then sanely share A<sub>10</sub>.

<h5>Less obvious datapath</h5>

<p>Instead, A<sub>6</sub> could have inputs to receive <tt>1(3-1)</tt> and
<tt>1(6-1)</tt>. <code>N3D6</code> would have to use the <tt>1(6-1)</tt> input
to affect <tt>a6(4)</tt> as it does, but that is plausible.

<p>With this setup, it's much more efficient to subtract out the rightmost
digits of A<sub>6</sub> than to stitch fields together. A<sub>10</sub> would
have inputs for <tt>3(3-1)</tt> instead of <tt>3(11-4)</tt>, and <tt>3(6-1)</tt>
instead of <tt>3(11-6)</tt>.

<pre>
  # Alternative 6R3 sequence
  7. a10:SC1, a13:β01  # Save -a10 [2]
  8. a6:A01, (a10:β01) # Send a6(3-1) [3,3(3-1)]
  9. a10:SC1, a6:α01   # Clear a6(3-1) [2]
 10. a15:AC1, a10:α01  # Get a15 in a10 to use trunk 1 [2]
 11. a10:AC1, (a6:β01) # Add a15(3-1) [1,1(3-1)]
 12. a13:SC1, a10:α01  # Restore -a10 [2]
 13. [[C-5]]
</pre>

<p>This matches the timing, and more literally follows the prose descriptions of
the instructions in all the sources, e.g. <q>Clear 6(3,2,1)</q>. It would remove
two inputs on A<sub>10</sub> and permit sharing A<sub>10</sub> for all the
control flow instructions. However it does require connecting <tt>a6.ε</tt>,
used by the PC increment program <tt>a6:εC1</tt>, which means we need to think
about overlap with fetch in cycle 11 for <a href="#a1tmp">A<sub>1</sub>
based</a> instructions.

<h5>Common sequence</h5>

<p>This sequence begins at cycle 7 for <code>6Rx</code> but cycle 8 for
<code>C.T.</code>.  To avoid confusion, we label the cycles 0-6.

<<Instructions: control flow common>>=
# This sequence is initiated by K-1.

# Cycle 0: Save and clear a10
<<Instructions: control flow cycle 0>>
# Cycle 1: Send a6 (a10 program per instruction)
#            Reset order selector ring
<<Instructions: control flow cycle 1>>
# Cycle 2: Clear field of a6
<<Instructions: control flow cycle 2>>
# Cycle 3: Get a15 in a10 to use trunk 1
<<Instructions: control flow cycle 3>>
# Cycle 4: Send a10 (a6 program per instruction)
<<Instructions: control flow cycle 4>>
# Cycle 5: Restore a10
<<Instructions: control flow cycle 5>>
# Cycle 6: (Fetch and decode next instruction)
@ %def K-1

<h5>Control flow cycle 0</h5>

<<Instructions: control flow cycle 0>>=
# Transmit -a10 on trunk 2
p K-1 a10.6i
s a10.op6 S
s a10.cc6 C
s a10.rp6 1
p a10.6o K-2
# Receive at a13 (on trunk 2)
# Use a program on a13 since it is shared by three instructions.
# NOTE: This could use B-4 instead.
p K-1 a13.9i
s a13.op9 β
s a13.cc9 0
s a13.rp9 1

# Dummy to reset order selector ring in cycle 1.
p K-1 a4.12i
s a4.op12 0
s a4.cc12 0
s a4.rp12 1
p a4.12o G-6
@ %def K-2

<h5>Control flow cycle 1</h5>

<<Instructions: control flow cycle 1>>=
# Transmit and hold a6
# NOTE: Could use J-2 to save a program on a6.
p K-2 a6.9i
s a6.op9 A
s a6.cc9 0
s a6.rp9 1
p a6.9o K-3
# (per-instruction sequences receive at a10)
@ %def K-3

<h5>Control flow cycle 2</h5>

<<Instructions: control flow cycle 2>>=
# Transmit -a10 on trunk 2
p K-3 a10.7i
s a10.op7 S
s a10.cc7 C
s a10.rp7 1
p a10.7o K-4
# Add -a10 to a6 via trunk 2,
# clearing either a6(6-1) or a6(3-1)
p K-3 a6.2i
s a6.op2 α
s a6.cc2 0

# Dummy to trigger a15:AC1 in cycle 3
p K-3 c.18i
p c.18o J-1
@ %def K-4

<h5>Control flow cycle 3</h5>

<<Instructions: control flow cycle 3>>=
# J-1 triggers a15:AC1
# Receive a10 on trunk 2
p K-4 a10.8i
s a10.op8 α
s a10.cc8 0
s a10.rp8 1
p a10.8o K-5
@ %def K-5

<h5>Control flow cycle 4</h5>

<<Instructions: control flow cycle 4>>=
# Transmit a10 on trunk 1
p K-5 a10.9i
s a10.op9 A
s a10.cc9 C
s a10.rp9 1
p a10.9o K-6
# (per-instruction sequences receive at a6)

# Dummy to trigger a13:SC1 in cycle 5
p K-5 a3.8i
s a3.op8 0
s a3.cc8 0
s a3.rp8 1
p a3.8o B-10
@ %def K-6

<h5>Control flow cycle 5</h5>

<<Instructions: control flow cycle 5>>=
# B-10 triggers a13:SC1
# Receive saved -a10 on trunk 2
p K-6 a10.10i
s a10.op10 α
s a10.cc10 0
s a10.rp10 1
p a10.10o C-5

# C-5 triggers the next instruction fetch in cycle 6.
@

<h4>6R3</h4>

<p>LCS48 does not specify what happens to the unused digits of A<sub>15</sub>
for <code>6Rx</code>, but DU49 specifies that they're cleared, so let's go with
that.

<pre>
  7. (a10:SC1, a13:β01)  # Save -a10 [2]
  8. (a6:A01), a10:β01   # Send a6(3-1) [3,3(3-1)]
  9. (a10:SC1, a6:α01)   # Clear a6(3-1) [2]
 10. (a15:AC1, a10:α01)  # Get a15 in a10 to use trunk 1 [2]
 11. (a10:AC1), a6:β01   # Add a15(3-1), updating PC [1,1(3-1)]
 12. (a13:SC1, a10:α01)  # Restore -a10 [2]
 13. [[C-5]]                 # Fetch and decode
</pre>

<<Instructions: 6R3>>=
# 6R3

# Pulse amplifiers trigger K-1

# Cycle 7: Wait
# Dummy to delay 6R3 = E-6
p E-6 c.21i
p c.21o K-7

# Cycle 8: Receive a6(3-1) at a10
p K-7 a10.3i
s a10.op3 β
s a10.cc3 0
# Dummy to wait for cycle 11.
p K-7 a2.8i
s a2.op8 0
s a2.cc8 0
s a2.rp8 3
p a2.8o K-8

# Cycle 11: Receive a15(3-1) at a6
p K-8 a6.3i
s a6.op3 β
s a6.cc3 0
@ %def K-7 K-8

<h4>6R6</h4>

<p>DU49 still has this instruction, but DEC51 changes its semantics; instead it
assigns opcode 79 to <code>6<sub>3</sub></code> which saves <tt>15(3,2,1)</tt>
into <tt>6(6,5,4)</tt> without clobbering the PC. <code>6<sub>3</sub></code>
uses A<sub>20</sub> (20-13&rarr;20).

<pre>
  7. (a10:SC1, a13:β01)  # Save -a10 [2]
  8. (a6:A01), a10:γ01   # Send a6(6-1) [3,3(6-1)]
  9. (a10:SC1, a6:α01)   # Clear a6(6-1) [2]
 10. (a15:AC1, a10:α01)  # Get a15 in a10 to use trunk 1 [2]
 11. (a10:AC1), a6:γ01   # Add a15(6-1), updating PC [1,1(6-1)]
 12. (a13:SC1, a10:α01)  # Restore -a10 [2]
 13. [[C-5]]                 # Fetch and decode
</pre>

<<Instructions: 6R6>>=
# 6R6, shared by C.T.

# Pulse amplifiers trigger K-1

# Cycle 7: Wait
# Dummy to delay 6R6 = E-7
p E-7 c.22i
p c.22o K-9

# Cycle 8: Receive a6(6-1) at a10
p K-9 a10.4i
s a10.op4 γ
s a10.cc4 0
# Dummy to wait for cycle 11.
p K-9 a2.7i
s a2.op7 0
s a2.cc7 0
s a2.rp7 3
p a2.7o K-10

# Cycle 11: Receive a15(6-1) at a6
p K-10 a6.4i
s a6.op4 γ
s a6.cc4 0
@ %def K-9 K-10

<h4>C.T.</h4>

<p>LCS48 sneaks a mention of another new two-position stepper, <q>P-M
discriminator no. 2</q>, in the text above Section IV. It's a good thing, as
without such a unit, magnitude discrimination would require a dedicated
accumulator as described in ETM 4.5.3.

<p>An obvious datapath for <code>C.T.</code> would use a single
<tt>3(11-7,000,6-4)</tt> input on A<sub>10</sub>. But the 14 cycle timing and
reuse of A<sub>10</sub> suggests this shares a sequence with <code>6Rx</code>.

<p>In fact we can directly reuse the <code>6R6</code> sequence if we allocate a
precious input on A<sub>15</sub> to receive <tt>a6(6-4)</tt>. This convenience
would explain the otherwise curious instruction behavior of clearing
A<sub>15</sub>, as naively it'd be wiser to preserve a loop variable near a
branch&mdash;A<sub>15</sub> is re-purposed as the target.

<pre>
  4. ([[F-5]])         # Reset discriminator
  &vellip;
  7. a15:AC1, [[G-2]]  # Discriminate P-M
  M8. [[C-5]]       P8. (a10:SC1, a13:β01)  # Save -a10 [2]
                P9. (a6:A01, a10:γ01),  # Send a6(6-1) [3,3(6-1)]
                    a15:ε01             # Get a6(6-4) in a15(3-1) [3,3*]
               P10. (a10:SC1, a6:α01)   # Clear a6(6-1) [2]
               P11. (a15:AC1, a10:α01)  # Get a15 in a10 to use trunk 1 [2]
               P12. (a10:AC1, a6:γ01)   # Add a15(6-1), updating PC [1,1(6-1)]
               P13. (a13:SC1, a10:α01)  # Restore -a10 [2]
               P14. [[C-5]]                 # Fetch and decode
</pre>

<<Instructions: C.T.>>=
# C.T.

# Cycle 4-7: PM discrimination
<<Instructions: C.T. cycle 4-7>>
# Cycle M8: (Fetch and decode next instruction.)
# Cycle P8: Await cycle P9.
<<Instructions: C.T. cycle P8>>
# Cycle P9: Get target in a15.
<<Instructions: C.T. cycle P9>>
# Cycle P10-14: (Common with K-1)
@

<h5>Cycle 4-7</h5>

<p>RIF shows part of the wiring for <q>P.M. Discriminator #2</q>, and
the connection 9&rarr;[[C-5]] would make sense for <code>C.T.</code>, so we can
probably assume it's the same.  Curiously, RIF shows [[G-4]] not the decode
[[G-2]] connected to <tt>i</tt>.  Given the [[C-5]] connection, it seems
unlikely the discriminator could have been reused, and it needs to operate in
cycle 7, so we just use [[G-4]] instead.

<p>An interesting implementation question is when the discriminator is reset,
but unfortunately RIF cuts off above <tt>cdi</tt>.  We'll just reset it along
with other steppers as part of the fetch sequence.

<<Instructions: C.T. cycle 4-7>>=
# Cycle 4: Reset discriminator
p F-5 pm2.cdi

# Cycle 7: Discriminate P-M
# G-2 -> J-1 triggers a15:AC1
p G-2 pm2.i   # C.T.
p G-3 pm2.di  # 2(11)
p pm2.1o G-5  # + taken sequence
p pm2.2o C-5  # - fetch next instruction
@ %def G-5

<h5>Cycle P8</h5>

<<Instructions: C.T. cycle P8>>=
# Cycle P8: Await cycle P9.
# G-5 -> E-7 triggers the 6R6 sequence
p G-5 a3.7i
s a3.op7 0
s a3.cc7 0
s a3.rp7 1
p a3.7o K-11
@ %def K-11

<h5>Cycle P9</h5>

<<Instructions: C.T. cycle P9>>=
# Cycle P9: Receive a6(6-4) in a15(3-1)
p K-11 a15.4i
s a15.op4 ε
s a15.cc4 0
@

<h4>18↔20</h4>

<p>LCS48 lists <code>18↔20</code> as 9 cycles, even though in theory it could
overlap fetch&mdash;perhaps the [[C-5]] dummy <tt>a20.12i</tt> was the issue?
<code>18↔20</code> is gone from DU49 and DEC51. LCS48 Section IV suggests
A<sub>15</sub> must be 0 on entry, so assume it's used for the exchange.

<pre>
  7. a20:AC1, a15:β01  # Save a20 in a15 [1]
  8. a18:AC1, a20:β01  # a18 to a20 [1]
  9. a15:AC1, a18:α01  # Saved a20 to a18 [2]
</pre>

<<Instructions: 18↔20>>=
# 18↔20

# Cycle 7: Save a20 in a15.
# Transmit a20
p C-3 a20.5i
s a20.op5 A
s a20.cc5 C
s a20.rp5 1
p a20.5o Q-7
# C-3 -> J-1 triggers a15:β01

# Cycle 8: a18 to a20
# Transmit a18
p Q-7 a18.10i
s a18.op10 A
s a18.cc10 C
s a18.rp10 1
p a18.10o J-1  # Trigger a15:AC1 in cycle 9
# Receive a20
p Q-7 a20.6i
s a20.op6 β
s a20.cc6 0
s a20.rp6 1
p a20.6o Q-8

# Dummy to trigger C-5 in cycle 9
p Q-7 a4.11i
s a4.op4 0
s a4.cc4 0
s a4.rp4 1
p a4.11o C-5

# Cycle 9: Saved a20 to a18
# J-1 triggers a15:AC1
# Receive a18 on trunk 2
p Q-8 a18.3i
s a18.op3 α
s a18.cc3 0
@ %def Q-7 Q-8

<h4><a name=ft>F.T.</a></h4>

<p><code>F.T.</code> fetches data from a function table in 13 cycles by reusing
fetch machinery without triggering decode. 

<<Instructions: F.T.>>=
# F.T.

# Cycle 7: Decode address from a8
<<Instructions: F.T. cycle 7>>
# Cycle 8: Initiate ft read, increment address, clear a11
<<Instructions: F.T. cycle 8>>
# Cycle 12: Store ft data in a11 and a15
<<Instructions: F.T. cycle 12>>
@

<h5>Addressing</h5>

<p>LCS48 says only that <code>F.T.</code> expects an address in A<sub>8</sub>.
But there's a problem if digit 3 of the address is supposed to be 0-2 like it is
for the PC, since <tt>ft.1i</tt> is set up to send [[J-4]] which would trigger
PC increment and advance the order selector ring, skipping the next instruction.

<p>The ballistics program in LCS48 has <code>N4D 04 86 8l F.T.</code>
which&mdash;apart from the fact that FT2's constant data has address 90 in that
listing&mdash;suggests that we're supposed to code 3-5 instead of 0-2 for
function table 1/2/3 for <code>F.T.</code> DU49 corroborates this encoding, and
clarifies that instruction lookups use A-2 addressing, and data lookups use A+2
addressing, to permit using lines -2 through 101 of each table. So <code>N4D 04
86 8l F.T.</code> would index line 88 of table 2, which in the A-2 instruction
address space is (confusingly) line 90.

<p>If you wrote <code>N4D 01 00 8l F.T.</code> by mistake, it would most likely
hang, fetching the next instruction but not decoding it.

<h5>Cycle 7</h5>

<<Instructions: F.T. cycle 7>>=
# Transmit (and hold) a8 as ft address
p H-11 a8.6i  # F.T.
s a8.op6 A
s a8.cc6 0
s a8.rp6 1
p a8.6o N-6

# Decode digit 3 of address using ft selector
# use G-9, G-10, and G-11 for E-8=3,4,5
p sft.4o G-9
p sft.5o G-10
p sft.6o G-11
# H-11 -> E-1 triggers ft read via pulse amplifier
@ %def N-6 G-9 G-10 G-11

<h5>Cycle 8</h5>

<<Instructions: F.T. cycle 8>>=
# Read function table, using C to trigger sending the argument.
# Note this uses A+2 addressing.
p G-9 f1.2i
s f1.op2 A+2
s f1.cl2 C
s f1.rp2 1
p f1.C N-10

p G-10 f2.2i
s f2.op2 A+2
s f2.cl2 C
s f2.rp2 1
p f2.C N-10

p G-11 f3.2i
s f3.op2 A+2
s f3.cl2 0
s f3.rp2 1
p f3.C N-10

# Look up signs from the tables, too.
s f1.mpm1 T
s f1.mpm2 T
s f2.mpm1 T
s f2.mpm2 T
s f3.mpm1 T
s f3.mpm2 T

# Post-increment address
p N-6 a8.3i
s a8.op3 ε
s a8.cc3 C
# Clear a11.
# NOTE: Could use J-3 instead.
p N-6 a11.11i
s a11.op11 0
s a11.cc11 C
s a11.rp11 1
@ %def N-10

<h5>Cycle 12</h5>

<<Instructions: F.T. cycle 12>>=
# The function table sends data on trunk 3 and 4 this cycle
# Receive left digits at a11
p N-10 a11.12i
s a11.op12 β
s a11.cc12 0
s a11.rp12 1
p a11.12o C-5  # Fetch and decode next instruction
# Receive right digits at a15
p N-10 a15.7i
s a15.op7 γ
s a15.cc7 0
s a15.rp7 1
@

<h4>Pr.</h4>

<<Instructions: Pr.>>=
# Printer
# TODO Add some way to specify printer wiring to the simulator.  This
# ISA expects to print a1, a2, and a15-20.
p O-1 i.Pi  # Pr.
p i.Po C-5  # fetch+decode
s pr.1 P    # a1
s pr.2 P    # a1
s pr.3 P    # a2
s pr.4 P    # a2
s pr.5 P    # a15
s pr.6 P    # a15
s pr.7 P    # a16
s pr.8 P    # a16
s pr.9 P    # a17
s pr.10 P   # a17
s pr.11 P   # a18
s pr.12 P   # a18
s pr.13 P   # a19
s pr.14 P   # a19
s pr.15 P   # a20
s pr.16 P   # a20
@

<h4>Rd.</h4>

<<Instructions: Rd.>>=
# Reader
p O-2 i.Ri  # Rd.
p i.Ro C-5  # fetch+decode
@

<h4><a name=shifts>Sh and Sh'</a></h4>

<h5>What do they actually do</h5>

<p>The vaguest instructions in LCS48 are the shifts, <code>Sh jk</code> and
<code>Sh' jk</code>.  DU49 and DEC51 use a different encoding, but we can
probably assume the same semantics&mdash;they at least clarify that the shifts
are supposed to be arithmetic.  <code>Sh</code> operates on A<sub>15</sub>
alone, and <code>Sh'</code> also operates on A<sub>12</sub> to shift
A<sub>15</sub>=Sabcdefghij as described in this diagram:

<pre>
  Shift(')    jk     New a12(')   New a15
 Sabcdefghij  01 -> S?????????a  Sbcdefghij0      S = sign digit
              02 -> S????????ab  Scdefghij00      ? = 0 would make sense, but
              03 -> S???????abc  Sdefghij000          not specified.
              04 -> S??????abcd  Sefghij0000
              05 -> S?????abcde  Sfghij00000
              91 -> Sj000000000  SSabcdefghi
              92 -> Sij00000000  SSSabcdefgh
              93 -> Shij0000000  SSSSabcdefg
              94 -> Sghij000000  SSSSSabcdef
              95 -> Sfghij00000  SSSSSSabcde
</pre>

<p>All the references are unclear about sign extension into A<sub>12</sub> for
<code>Sh' 0x</code>.  The example programs in LCS48 don't help much; in the
ballistics problem, <code>Sh'</code> is used exclusively with negative
arguments to put immediate values at the top of A<sub>12</sub>, e.g. <code>N2D
01 Sh' 92</code>&mdash;how RISCy!  The self-test program in LCS48 Table 5.I
shifts a test input left by n and adds A<sub>12</sub> to A<sub>15</sub>
(effectively rotating left by n), then rotates back right by n and subtracts
the result from an expected value.
<pre>
  10t     ; Get test input in 15
  Sh' 01  ; Shift left 1 (abcdefghij)
  12t     ; ?????????a + bcdefghij0 = bcdefghija?
  Sh' 91  ; Shift right 1 (bcdefghija)
  12t     ; a000000000 + Sbcdefghij? = abcdefghij?
  M       ; Complement answer
  14t     ; Subtract from expected output 1
  1l      ; Test result in 1
</pre>

<p>LCS48 says only that this takes 20 cycles and uses A<sub>13</sub>.  Just
fetching <code>jk</code> takes 12 cycles, so decoding <code>jk</code> and doing
the work must fit in 8 cycles.  DU49 uses its extra code space to avoid
requiring an operand and claims an impressive 9 cycles, i.e. fetch + 3 cycles.
DEC51 says 12 cycles i.e. fetch + 6 cycles and implies using A<sub>14</sub>
(14-13&rarr;14).  6/8 cycles vs 3 cycles of work might mean two different
datapaths&mdash;3 cycles suggests a bunch of shift adapters, while 6/8 cycles
(with just a single temporary called out for side-effects) implies incremental
shifting.

<h5>A bunch of adapters</h5>
<p>An easy datapath would just use twenty shift adapters.  For instance say
<tt>aK.δ</tt> shifts @<< k and <tt>aK.ε</tt> shifts @>> (10-k).
<pre>
 12-13. (decode jk)
 14. aK:AC1, a13:γ01, (a12:0C1)' # Save aK in a13 [1]
 15. a15:A01, aK:δ01, (a12:α01)' # Shift a15 in aK ('save in a12) [2,2*]
 16. aK:AC1, a15:β01             # Store new a15 [1]
 17. (a12:AC1)', aK:ε01          # Shift old a15 again in aK [1,1*]
 18. aK:AC1, (a12:β01)'          # Store new a12 [1]
 19. a13:AC1, aK:β01             # Restore aK from a13 [1]
 20. (fetch)
</pre>
<p>Steps marked with <tt>'</tt> are done only for <code>Sh'</code>.  This
requires three inputs each on ten accumulators, one input on trunk 1 and 2
inputs per shift.  Those fit all right.

<p>The challenge with this approach is programming it.  <code>Sh'</code> can
nicely reuse the same sequences as <code>Sh</code> with an orthogonal four
program sequence on A<sub>12</sub>.  But each of ten <tt>jk</tt>s needs a
separate six cycle sequence, consuming 60 of 160 available repeat programs and
up to 60 pulse amplifier channels, assuming no magic new hardware.  This is
probably too expensive.

<h5>Incremental shifting, slowly</h5>

<p>An incremental datapath uses the same accumulators for all shift amounts, so
there could be one shift sequence per direction, <tt>j</tt>.  <tt>k</tt> might
trigger e.g. step <tt>14+2(k-1)</tt> of the sequence,
<pre>
  12-13. (decode jk)
  # Initially a13=x, a14=0.
  14. a13:AC1, a14:δ01  # Shift x by one digit
  15. a14:AC1, a13:γ01  # Get x back in a13
  16. a13:AC1, a14:δ01  # Shift x by one digit
  17. a14:AC1, a13:γ01  # Get x back in a13
  &vellip;
  13+2(k-1). a13:AC1, a14:δ01
  14+2(k-1)+1. a14:AC1, a13:γ01
  &vellip;
</pre>
<p>But this would have variable timing which no reference mentions.  Instead,
to decouple <tt>j</tt> and <tt>k</tt> decode, <tt>j</tt> might control which
receive program is active for 5 rounds and <tt>k</tt> might trigger 1-5
transmit steps.
<pre>
  o-o-o-o-o -> a14:δ01/a13:γ01
  j=9
  o-o-o-o-o -> a14:ε01/a13:γ01
  j=0
  o-o-o-o-o -> a13:AC1/a14:AC1
  5 4 3 2 1 = k
  (Each dummy program here has rp2)
</pre>
<p><code>Sh'</code> requires an extra two steps per round.
<pre>
  12. (decode jk)
  # Initially a12'=0, a13=x, a14=0, a15=tmp.
  13. (a12:AC1)', a14:ε01   # residual @<<= 1 to make room for new digit
  14. a14:AC1, (a12:γ01)'   # Get residual back in a12
  15. a13:AC1, a14:δ01, (a12:δ01)' # Shift in/out new digit
  16. a14:AC1, a13:γ01
   &vellip;
</pre>
<p><code>Sh'</code> control can be accomplished as one more parallel sequence
on A<sub>12</sub> per round.  This would come out to 13 cycles fetch/decode +
20 cycles for shifting + 2-3 for temporary shuffling, with around 20-30 repeat
programs.  This seems way too slow.

<h5>Incremental shifting, ping-ponging</h5>

<p>A faster way to shift A<sub>13</sub> by +5 incrementally is to ping-pong
between accumulators which each have a shift input, e.g.
<pre>
 # Initially a13=x, a14=0.
 13. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<1)
 14. a14:AC1, a13:δ01  # Shift +1 (-> a13=x@<<2, a14=0) 
 15. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<3)
 16. a14:AC1, a13:δ01  # Shift +1 (-> a13=x@<<4, a14=0) 
 17. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<5)
</pre>
<p>Because the transmitting accumulator alternates, even/odd shifts leave the
answer in different places.  Collecting the answer based on <tt>k (mod 2)</tt>
after shifting concludes requires separately timed dummy programs.
<pre>
  o-o-o-o-o   a14:δ01/a13:δ01
  j=9
  o-o-o-o-o   a14:ε01/a13:ε01
  j=0
  o-o-o-o-o-x a13:AC1/a14:AC1
    o-------o (swap a13/a14)
        o---'
  5 4 3 2 1 = k
</pre>

<p><code>Sh'</code> is harder.  We could cycle between the three available
accumulators if they had both ±1 and ±9 adapters, but there aren't enough free
inputs on either A<sub>13</sub> or A<sub>15</sub>.  Pre-shifting by ±5 would
let us incrementally shift the rest of the way to A<sub>12</sub> using ±1
shifters, e.g.
<pre>
 # (Pre-shift x±5 so that a sequence of ±1 shifts can compute the residual.)
 12. (decode jk)
 # Initially e.g. a12=r, a13=x, a14=0
 13. a12:AC1, a14:ε01          # -> a12=0 a13=x a14=r
 14. a13:AC1, a12:δ01, a14:δ01 # -> a12=x a13=0 a14=r
 15. a14:AC1, a13:ε01          # -> a12=x a13=r a14=0
 16. a12:AC1, a13:δ01, a14:δ01 # -> a12=0 a13=r a14=x
 17. a13:AC1, a12:ε01          # -> a12=r a13=0 a14=x
 18. a14:AC1, a12:δ01, a13:δ01 # -> a12=r a13=x a14=0
 19. a12:AC1, a14:ε01          # -> a12=0 a13=x a14=r
 20. a13:AC1, a12:δ01, a14:δ01 # -> a12=x a13=0 a14=r
 21. a14:AC1, a13:ε01          # -> a12=x a13=r a14=0
 22. a12:AC1, a13:δ01, a14:δ01 # -> a12=0 a13=r a14=x
</pre>
<p>However, this would need to be a separate sequence since <code>Sh</code>
doesn't reserve A<sub>12</sub>, and that seems too clunky.

<h5>Incremental shifting, weighted shifts</h5>

<p>A cleverer approach would be to use an optional ±2/±4 shift on
A<sub>14</sub> followed by a ±1 shift on A<sub>13</sub>.  Computing
A<sub>12</sub> for <code>Sh'</code> would use another ±2/±4, ±1 shift sequence
followed by ±5 which should probably be done last, on A<sub>12</sub>.

<table>
<tr><th>shift<th>residual<th>answer<th style="border-left: 4px solid #ccc">shift<th>residual<th>answer
<tr><td>+1<td>-4-5<td>+1    <td style="border-left: 4px solid #ccc">-1<td>+4+5<td>-1
<tr><td>+2<td>-2-1-5<td>+2  <td style="border-left: 4px solid #ccc">-2<td>+2+1+5<td>-2
<tr><td>+3<td>-2-5<td>+2+1  <td style="border-left: 4px solid #ccc">-3<td>+2+5<td>-2-1
<tr><td>+4<td>-1-5<td>+4    <td style="border-left: 4px solid #ccc">-4<td>+1+5<td>-4
<tr><td>+5<td>-5<td>+4+1    <td style="border-left: 4px solid #ccc">-5<td>+5<td>-4-1
</table>
<pre>
   7. a14:SC1, a13:β01, (a12:0C1)' # Save -a14 [2]
   &vellip;
  12-13. (decode jk)
  14. a15:AC1, a14:[αβγδε]01,  # Shift answer 0/±2/±4,
      (a12:[αβγδε]01)'         # and residual 0/±2/±4 [2]
  15. a13:AC1, a15:β01         # Shuffle temp to a15 [1]
  16. a14:AC1, a13:[γδε]01     # Shift answer 0/±1 [1]
  17. a15:AC1, a14:α01         # Restore -a14 [2]
  18. a13:AC1, a15:β01         # Answer to a15 [1]

  19. a12:AC1, a13:[γδε]01     # Shift residual 0/±1 [1]
  20. a13:AC1, a12:


  16. a12:AC1, a13:[γδε]01
  17. a13:AC1, a12:

  15. a13:AC1, a15:β01         # Move saved -a14 to a15
  16. a14:AC1, a13:[γδε]01     # Shift answer   17. 

  14. a13:AC1,    a14:[βγδε]01 # Shift answer ±4/±2 [2]
  15. a14:AC1,    a13:[γδε]01  # Shift answer 0/±1 [1]
  16. a15:AC1,    a14:α01      # Restore a14
  17. a13:AC1,    a15:β01      # Save answer
  18. (a12:AC1)', a13:[γδε]01  # Shift residual 0/±1 [1]
  19. (a13:AC1)', a12:[βγδε]01 # Shift residual ±4/±2 [1]
  20. (fetch)
</pre>

<p>The control is expensive.  Direction and shift amount are not orthogonal,
and it isn't entirely clear that <code>Sh'</code> can be either.  With the
crunch for temporaries, it's slower than the clunky

<h4>Decoding jk</h4>
<p>LCS48 says nothing about decoding jk, and it was gone by DU49. Section II
says that <q>by the addition of four small units, it became possible to
speed the process up considerably and have 60 orders</q>, then goes on to
mention
<ol>
<li>Ten-stage stepper
<li>Order selector
<li>Function table selector
</ol>
<p>So something is certainly missing here.  (P-M discriminators aren't
mentioned until Section III, and then only in passing, so probably aren't one
of the <q>four small units</q> added for decode).

<p>The least inventive solution is to throw more hardware at the problem, e.g.
a P-M discriminator (j) wired to two additional six-stage steppers (k)
analogous to the FT selector.  Wilder possibilities abound... the complement of
k=1-5 could drive a counter whose sign says to shift one step, we could somehow
reuse instruction decode with an additional layer of output gating, etc.

<h4>Implementation</h4>
<p>Lacking any evidence about plans for decode hardware, this implementation
uses some additional steppers that control a bunch of shifters.  The control
for an incremental datapath is too elaborate.

<h2><a name=prog>Program line assignments</a></h2>

<p>This is an index of program line assignments at a glance.  Blue shaded cells
represent assignments specified in LCS48, pink cells are from RIF, and
non-shaded cells are specific to this implementation.  <tt>noweb</tt> also
generates a separate, cross-referenced textual <a href="#index">index</a>.

<table class="dense" style="text-align: center; padding: 2px;">
<tr><td><th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<th>11
<tr style="vertical-align: top"><td style="font-weight: bold">A-
<td>[[A-1]]<br>init
<td>[[A-2]]<br>
<td>[[A-3]]<br>
<td>[[A-4]]<br>
<td>[[A-5]]<br>
<td>[[A-6]]<br>
<td>[[A-7]]<br>
<td>[[A-8]]<br>
<td>[[A-9]]<br>
<td>[[A-10]]<br>
<td>[[A-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">B-
<td class=given>[[B-1]]<br>√
<td class=given2>[[B-2]]<br>i0x
<td class=given>[[B-3]]<br>a15recv
<td class=given>[[B-4]]<br>a13recv
<td class=given2>[[B-5]]<br>i1x
<td>[[B-6]]<br>
<td>[[B-7]]<br>
<td>[[B-8]]<br>
<td>[[B-9]]<br>
<td>[[B-10]]<br>a13send-
<td>[[B-11]]<br>a13send
<tr style="vertical-align: top"><td style="font-weight: bold">C-
<td class=given>[[C-1]]<br>xl
<td class=given>[[C-2]]<br>8t
<td class=given>[[C-3]]<br>18↔20
<td class=given>[[C-4]]<br>a1tmp+8
<td class=given>[[C-5]]<br>decode
<td class=given>[[C-6]]<br>a18tmp
<td class=given>[[C-7]]<br>13l
<td class=given>[[C-8]]<br>20l
<td class=given>[[C-9]]<br>16t
<td class=given>[[C-10]]<br>Sh'
<td class=given>[[C-11]]<br>Sh
<tr style="vertical-align: top"><td style="font-weight: bold">D-
<td>[[D-1]]<br>
<td>[[D-2]]<br>
<td class=given>[[D-3]]<br>xt
<td class=given>[[D-4]]<br>const
<td class=given>[[D-5]]<br>a1tmp
<td class=given>[[D-6]]<br>fetch
<td class=given>[[D-7]]<br>AB
<td class=given>[[D-8]]<br>CD
<td class=given>[[D-9]]<br>EF
<td class=given>[[D-10]]<br>GH
<td class=given>[[D-11]]<br>JK
<tr style="vertical-align: top"><td style="font-weight: bold">E-
<td class=given>[[E-1]]<br>ftrd
<td class=given2>[[E-2]]<br>2(1)
<td class=given>[[E-3]]<br>÷
<td class=given>[[E-4]]<br>6l
<td class=given>[[E-5]]<br>X
<td class=given>[[E-6]]<br>6R3
<td class=given>[[E-7]]<br>6R6
<td class=given>[[E-8]]<br>3(3)
<td class=given>[[E-9]]<br>sft.cdi
<td class=given>[[E-10]]<br>os.i
<td class=given>[[E-11]]<br>sft.1o
<tr style="vertical-align: top"><td style="font-weight: bold">F-
<td class=given>[[F-1]]<br>sft.2o
<td class=given>[[F-2]]<br>sft.3o
<td class=given>[[F-3]]<br>os.Ri
<td class=given>[[F-4]]<br>PC inc
<td class=given>[[F-5]]<br>p.cdi
<td class=given2>[[F-6]]<br>2(2)
<td class=given2>[[F-7]]<br>pm1.i
<td class=given2>[[F-8]]<br>pm1.9
<td class=given2>[[F-9]]<br>pm1.0
<td>[[F-10]]<br>
<td>[[F-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">G-
<td>[[G-1]]<br>
<td class=given>[[G-2]]<br>C.T.
<td class=given2>[[G-3]]<br>pm2.di
<td class=given2>[[G-4]]<br><s>pm2.i</s>
<td class=given2>[[G-5]]<br>pm2.0
<td class=given2>[[G-6]]<br>os.cdi
<td class=given2>[[G-7]]<br>pm1.cdi
<td class=given>[[G-8]]<br>os.i
<td>[[G-9]]<br>sft.4o
<td>[[G-10]]<br>sft.5o
<td>[[G-11]]<br>sft.6o
<tr style="vertical-align: top"><td style="font-weight: bold">H-
<td class=given>[[H-1]]<br>14l
<td class=given>[[H-2]]<br>16l
<td class=given>[[H-3]]<br>17l
<td class=given>[[H-4]]<br>18l
<td class=given>[[H-5]]<br>19l
<td class=given>[[H-6]]<br>17t
<td class=given>[[H-7]]<br>18t
<td class=given>[[H-8]]<br>19t
<td class=given>[[H-9]]<br>20t
<td class=given>[[H-10]]<br>DS
<td class=given>[[H-11]]<br>F.T.
<tr style="vertical-align: top"><td style="font-weight: bold">J-
<td class=given>[[J-1]]<br>a15send
<td class=given>[[J-2]]<br>pcseq
<td class=given>[[J-3]]<br>const'
<td class=given>[[J-4]]<br>ft.NC
<td>[[J-5]]<br>
<td>[[J-6]]<br>
<td>[[J-7]]<br>
<td>[[J-8]]<br>
<td>[[J-9]]<br>
<td>[[J-10]]<br>
<td>[[J-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">K-
<td>[[K-1]]<br>cflow+0
<td>[[K-2]]<br>cflow+1
<td>[[K-3]]<br>cflow+2
<td>[[K-4]]<br>cflow+3
<td>[[K-5]]<br>cflow+4
<td>[[K-6]]<br>cflow+5
<td>[[K-7]]<br>6r3+8
<td>[[K-8]]<br>6r3+9
<td>[[K-9]]<br>6r6+8
<td>[[K-10]]<br>6r6+9
<td>[[K-11]]<br>ct+9
<tr style="vertical-align: top"><td style="font-weight: bold">L-
<td class=given>[[L-1]]<br>9t
<td class=given>[[L-2]]<br>10t
<td class=given>[[L-3]]<br>11t
<td class=given>[[L-4]]<br>12t
<td class=given>[[L-5]]<br>13t
<td class=given>[[L-6]]<br>14t
<td class=given>[[L-7]]<br>8l
<td class=given>[[L-8]]<br>9l
<td class=given>[[L-9]]<br>10l
<td class=given>[[L-10]]<br>11ℓ
<td class=given>[[L-11]]<br>12l
<tr style="vertical-align: top"><td style="font-weight: bold">M-
<td>[[M-1]]<br>X+rs
<td>[[M-2]]<br>X+ds
<td>[[M-3]]<br>X+f
<td>[[M-4]]<br>
<td>[[M-5]]<br>
<td>[[M-6]]<br>
<td>[[M-7]]<br>
<td>[[M-8]]<br>
<td>[[M-9]]<br>
<td>[[M-10]]<br>
<td>[[M-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">N-
<td>[[N-1]]<br>n6d+12
<td>[[N-2]]<br>n4d+12
<td>[[N-3]]<br>n2d+12
<td>[[N-4]]<br>n2d+13
<td>[[N-5]]<br>n2d+14
<td>[[N-6]]<br>ft+8
<td>[[N-7]]<br>
<td>[[N-8]]<br>
<td>[[N-9]]<br>
<td>[[N-10]]<br>ft.C
<td>[[N-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">O-
<td class=given>[[O-1]]<br>Pr.
<td class=given>[[O-2]]<br>Rd.
<td>[[O-3]]<br>
<td class=given2>[[O-4]]<br>
<td>[[O-5]]<br>
<td>[[O-6]]<br>
<td>[[O-7]]<br>
<td class=given>[[O-8]]<br>a1recv
<td>[[O-9]]<br>
<td>[[O-10]]<br>
<td>[[O-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">P-
<td>[[P-1]]<br>
<td>[[P-2]]<br>
<td>[[P-3]]<br>
<td>[[P-4]]<br>
<td>[[P-5]]<br>
<td>[[P-6]]<br>
<td>[[P-7]]<br>
<td>[[P-8]]<br>
<td>[[P-9]]<br>
<td>[[P-10]]<br>
<td>[[P-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">Q-
<td>[[Q-1]]<br>div+8
<td>[[Q-2]]<br>div+11
<td>[[Q-3]]<br>div+x0
<td>[[Q-4]]<br>div+x1
<td>[[Q-5]]<br>div+x2
<td>[[Q-6]]<br>div+x3
<td>[[Q-7]]<br>1820+8
<td>[[Q-8]]<br>1820+9
<td>[[Q-9]]<br>
<td>[[Q-10]]<br>
<td>[[Q-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">R-
<td>[[R-1]]<br>sqrt+8
<td>[[R-2]]<br>sqrt+11
<td>[[R-3]]<br>sqrt+x0
<td>[[R-4]]<br>sqrt+x1
<td>[[R-5]]<br>sqrt+x2
<td>[[R-6]]<br>sqrt+x7
<td>[[R-7]]<br>ds+8
<td>[[R-8]]<br>ds+9
<td>[[R-9]]<br>ds+10
<td>[[R-10]]<br>divsq+9
<td>[[R-11]]<br>divsq+10
<tr style="vertical-align: top"><td style="font-weight: bold">S-
<td class=given>[[S-1]]<br>1ℓ
<td class=given>[[S-2]]<br>2l
<td class=given>[[S-3]]<br>3l
<td class=given>[[S-4]]<br>4l
<td class=given>[[S-5]]<br>5l
<td class=given>[[S-6]]<br>7l
<td class=given>[[S-7]]<br>2t
<td class=given>[[S-8]]<br>3t
<td class=given>[[S-9]]<br>4t
<td class=given>[[S-10]]<br>5t
<td class=given>[[S-11]]<br>7t
<tr style="vertical-align: top"><td style="font-weight: bold">T-
<td>[[T-1]]<br>611+8
<td>[[T-2]]<br>611+9
<td>[[T-3]]<br>611+10
<td>[[T-4]]<br>M+8
<td>[[T-5]]<br>M+10
<td class=given>[[T-6]]<br>const+8
<td>[[T-7]]<br>a1tmp+10
<td>[[T-8]]<br>a1tmp+11
<td>[[T-9]]<br>68+8
<td>[[T-10]]<br>68+9
<td>[[T-11]]<br>68+10
<tr style="vertical-align: top"><td style="font-weight: bold">V-
<td class=given>[[V-1]]<br>6t
<td class=given>[[V-2]]<br><span style="font-size:80%">6(11,10,9)</span>
<td class=given>[[V-3]]<br>M
<td class=given>[[V-4]]<br>6(8,7)
<td class=given>[[V-5]]<br>N2D
<td class=given>[[V-6]]<br>N4D
<td class=given>[[V-7]]<br>N6D
<td class=given>[[V-8]]<br>N3D8
<td class=given>[[V-9]]<br>1t
<td class=given2>[[V-10]]<br><s>div+8</s>
<td>[[V-11]]<br>
</table>

<h2><a name=accprog>Accumulator program allocation</a></h2>

<p>This chart shows accumulator program allocation by sequence. Cells correspond
to programs, with numbers given by their column, on the accumulator given by
their row. The top line of a cell shows what program line (if any) triggers that
program, and the bottom line says what sequence it is associated with. Dummies
are colored gray.

<table class="dense" style="text-align: center; padding: 2px;">
<tr>
<th>
<th>1i
<th>2i
<th>3i
<th>4i
<th>5i
<th>6i
<th>7i
<th>8i
<th>9i
<th>10i
<th>11i
<th>12i
<tr>
<td>[[a1]]<br>
<td title="1i">[[O-8]]<br>1ℓ
<td title="2i">[[V-9]]<br>1t
<td title="3i">[[T-8]]<br>a1tmp
<td title="4i">[[T-5]]<br>M
<td title="5i">[[S-1]]<br>1ℓ
<td title="6i">[[D-5]]<br>a1tmp
<td title="7i">[[T-2]]<br><span style="font-size:80%">6(11,10,9)</span>
<td title="8i">[[T-3]]<br><span style="font-size:80%">6(11,10,9)</span>
<td title="9i">[[T-10]]<br>6(8,7)
<td title="10i">[[T-11]]<br>6(8,7)
<td title="11i">[[T-4]]<br>M
<td title="12i" class=dummy>[[Q-1]]<br>div
<tr>
<td>[[a2]]<br>
<td title="1i">-<br>2l
<td title="2i">[[S-7]]<br>2t
<td title="3i">
<td title="4i">
<td title="5i">[[S-2]]<br>2l
<td title="6i" class=dummy>[[V-2]]<br><span style="font-size:80%">6(11,10,9)</span>
<td title="7i" class=dummy>[[K-9]]<br>6R6
<td title="8i" class=dummy>[[K-7]]<br>6R3
<td title="9i" class=dummy>[[R-8]]<br>DS
<td title="10i" class=dummy>[[H-10]]<br>DS
<td title="11i" class=dummy>[[R-1]]<br>sqrt
<td title="12i" class=dummy>[[A-1]]<br>reset
<tr>
<td>[[a3]]<br>
<td title="1i">-<br>3l
<td title="2i">[[S-8]]<br>3t
<td title="3i">
<td title="4i">
<td title="5i">[[S-3]]<br>3l
<td title="6i" class=dummy>[[V-4]]<br>6(8,7)
<td title="7i" class=dummy>[[G-5]]<br>C.T.
<td title="8i" class=dummy>[[K-5]]<br>cflow
<td title="9i" class=dummy>[[N-4]]<br>N2D
<td class=dummy>[[D-1]]<br>N2D
<td class=dummy>[[D-2]]<br>N4D
<td class=dummy>[[V-7]]<br>N6D
<tr>
<td>[[a4]]<br>Quot.
<td title="1i">-<br>4l
<td title="2i">[[S-9]]<br>4t
<td title="3i">
<td title="4i">
<td title="5i">[[S-4]]<br>4l
<td title="6i">[[Q-1]]<br>div
<td title="7i">[[Q-5]]<br>div
<td title="8i">[[Q-6]]<br>div
<td title="9i">
<td title="10i">
<td title="11i" class=dummy>[[Q-7]]<br>18↔20
<td title="12i" class=dummy>[[K-1]]<br>cflow
<tr>
<td>[[a5]]<br>Num
<td title="1i">-<br>5l
<td title="2i">[[S-10]]<br>5t
<td title="3i">
<td title="4i">
<td title="5i">[[S-5]]<br>5l
<td title="6i">[[R-10]]<br>divsq
<td title="7i">[[E-3]]<br>div
<td title="8i">[[B-1]]<br>sqrt
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a6]]<br>PC
<td title="1i">[[F-4]]<br>fetch
<td title="2i">[[K-3]]<br>cflow
<td title="3i">[[K-8]]<br>6R3
<td title="4i">[[K-10]]<br>6R6
<td title="5i">[[J-2]]<br>fetch
<td title="6i">[[J-4]]<br>fetch
<td title="7i">[[T-1]]<br><span style="font-size:80%">6(11,10,9)</span>
<td title="8i">[[T-9]]<br>6(8,7)
<td title="9i">[[K-2]]<br>cflow
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a7]]<br>Denom.
<td title="1i">-<br>7l
<td title="2i">[[S-11]]<br>7t
<td title="3i">
<td title="4i">
<td title="5i">[[S-6]]<br>7l
<td title="6i">[[R-1]]<br>sqrt
<td title="7i">[[R-5]]<br>sqrt
<td title="8i">[[R-6]]<br>sqrt
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a8]]<br>Arg.
<td title="1i">-<br>8l
<td title="2i">[[C-2]]<br>8t
<td title="3i">[[N-6]]<br>F.T.
<td title="4i">
<td title="5i">[[L-7]]<br>8l
<td title="6i">[[H-11]]<br>F.T.
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a9]]<br>Shift
<td title="1i">-<br>9l
<td title="2i">[[L-1]]<br>9t
<td title="3i">[[R-2]]<br>divsq
<td title="4i">
<td title="5i">[[L-8]]<br>9l
<td title="6i">[[Q-3]]<br>div
<td title="7i">[[Q-4]]<br>div
<td title="8i">[[R-3]]<br>sqrt
<td title="9i">[[R-4]]<br>sqrt
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a10]]<br>
<td title="1i">-<br>10l
<td title="2i">[[L-2]]<br>10t
<td title="3i">[[K-7]]<br>6R3
<td title="4i">[[K-9]]<br>6R6
<td title="5i">[[L-9]]<br>10l
<td title="6i">[[K-1]]<br>cflow
<td title="7i">[[K-3]]<br>cflow
<td title="8i">[[K-4]]<br>cflow
<td title="9i">[[K-5]]<br>cflow
<td title="10i">[[K-6]]<br>cflow
<td title="11i">
<td title="12i">
<tr>
<td>[[a11]]<br>Ier
<td title="1i">-<br>11ℓ
<td title="2i">[[L-3]]<br>11t
<td title="3i">[[T-6]]<br>const
<td title="4i">[[M-1]]<br>X
<td title="5i">[[L-10]]<br>11ℓ
<td title="6i">[[J-3]]<br>const
<td title="7i">[[H-10]]<br>DS
<td title="8i">[[R-7]]<br>DS
<td title="9i">[[R-8]]<br>DS
<td title="10i">[[R-9]]<br>DS
<td title="11i">[[N-6]]<br>F.T.
<td title="12i">[[N-10]]<br>F.T.
<tr>
<td>[[a12]]<br>Icand
<td title="1i">-<br>12l
<td title="2i">[[L-4]]<br>12t
<td title="3i">[[M-2]]<br>X
<td title="4i">
<td title="5i">[[L-11]]<br>12l
<td title="6i">[[E-5]]<br>X
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a13]]<br>LHPP
<td title="1i">-<br>13l
<td title="2i">[[L-5]]<br>13t
<td title="3i">[[B-4]]<br>*
<td title="4i">[[M-1]]<br>X
<td title="5i">[[C-7]]<br>13l
<td title="6i">[[B-11]]<br>*
<td title="7i">[[C-6]]<br>NxD
<td title="8i">[[B-10]]<br>*
<td title="9i">[[K-1]]<br>cflow
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a14]]<br>
<td title="1i">-<br>14l
<td title="2i">[[L-6]]<br>14t
<td title="3i">
<td title="4i">
<td title="5i">[[H-1]]<br>14l
<td title="6i">
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a15]]<br>RHPP
<td title="1i">[[J-1]]<br>*
<td title="2i">[[B-3]]<br>*
<td title="3i">[[C-2]]<br>8t
<td title="4i">[[K-11]]<br>C.T.
<td title="5i">[[T-7]]<br>a1tmp
<td title="6i">[[R-5]]<br>sqrt
<td title="7i">[[N-10]]<br>F.T.
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a16]]<br>
<td title="1i">-<br>16l
<td title="2i">[[C-9]]<br>16t
<td title="3i">
<td title="4i">
<td title="5i">[[H-2]]<br>16l
<td title="6i" class=dummy>[[V-3]]<br>M
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a17]]<br>
<td title="1i">-<br>17l
<td title="2i">17t
<td title="3i">
<td title="4i">
<td title="5i">[[H-3]]<br>17t
<td title="6i">
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i">
<tr>
<td>[[a18]]<br>
<td title="1i">-<br>18l
<td title="2i">[[H-7]]<br>18t
<td title="3i">[[Q-8]]<br>18↔20
<td title="4i">[[N-5]]<br>N2D
<td title="5i">[[H-4]]<br>18l
<td title="6i">[[N-1]]<br>N6D
<td title="7i">[[N-2]]<br>N4D
<td title="8i">[[N-3]]<br>N2D
<td title="9i">[[N-4]]<br>N2D
<td title="10i">[[Q-7]]<br>18↔20
<td title="11i">
<td title="12i">
<tr>
<td>[[a19]]<br>
<td title="1i">-<br>19l
<td title="2i">[[H-8]]<br>19t
<td title="3i">
<td title="4i">
<td title="5i">[[H-5]]<br>19l
<td title="6i">
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i" class=dummy>a1tmp
<tr>
<td>[[a20]]<br>
<td title="1i">
<td title="2i">
<td title="3i">
<td title="4i">
<td title="5i">[[C-3]]<br>18↔20
<td title="6i">[[Q-7]]<br>18↔20
<td title="7i">
<td title="8i">
<td title="9i">
<td title="10i">
<td title="11i">
<td title="12i" class=dummy>fetch
</table>

<h2><a name=index>Index</a></h2>
<h3>Chunks</h3>
<nowebchunks>
<h3>Identifiers</h3>
<nowebindex>

</body>
</html>
