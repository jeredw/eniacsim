<!doctype html>
<html>
<head>
<meta charset=utf-8>
<title>sixty.nw</title>
<style>
body {
  font-size: 120%;
  padding-left: 5em;
  padding-top: 2em;
  max-width: 50rem;
  line-height: 1.2;
}
table {
  margin: 1em;
  margin-left: -2em;
  border-collapse: collapse;
}
table td, table th {
  font-family: monospace;
  white-space: pre;
  border: 1px solid #ccc;
  padding: 1em;
}
table.dense {
  table-layout: fixed;
  width: 1100px;
}
table.dense td, table.dense th {
  padding: 2px 8px;
}
.given {
  background: #eff3ff;
}
.given2 {
  background: #ffd7f1;
}
</style>
</head>
<body>
<h1>Reconstruction of ENIAC 60 order code</h1>
(after <a href="https://ftp.arl.army.mil/~mike/comphist/48eniac-coding/">Clippinger 1948:
A Logical Coding System Applied to the ENIAC</a>)

<p>The 60 order code was a research instruction set for the ENIAC with 60
instructions, planned in detail but never installed.  It was designed for the
original ENIAC hardware with a few minimal additions.  <em>ENIAC in Action</em>
says that the wiring charts are in a box in the US National Archives&mdash;this
is an independent reconstruction based on a 1948 report (LCS48) and other
documents available on the web.

<p>LCS48 is both extremely detailed, giving many exact <a href="#prog">program
line assignments</a>, and silent on harder questions like what exactly the plan
was for <a href="#shifts">shifts</a>.  The 1949 report
<a href="https://eniacinaction.com/docs/DescriptionandUse1949.pdf">Description
and Use of the ENIAC Converter Code</a> (DU49) describes a derived instruction
set in better detail and offers some clues.  Also of interest is the much later
1951 <a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/642030.pdf">Description
of the Eniac Converter Code</a> (DEC51), by which time the instruction set had
graduated from research status to admit contract programming services and
computer rental for $35/hr or $800/day.

<p>One <a href="http://opentranscripts.org/wp-content/uploads/2016/02/working-on-eniac-0071-1280x960.jpg">random
image file</a> (RIF) on the Internet shows a tantalizing excerpt of a
hand-written program line index from late 1947 which matches up with
assignments in LCS48.

<p>The <a
href="https://www.amazon.com/Electronic-Numerical-Integrator-Computer-Technical/dp/1937684660">ENIAC
Technical Manual</a> (ETM) is helpful for clarifying how the machine is
supposed to work, and makes for great bedtime reading.

<h2>General notes</h2>

<p><b>Environment.</b>  This file has been prepared using the <a
href="https://www.cs.tufts.edu/~nr/noweb/">noweb</a> literate programming
system.  Code &lt;blocks&gt; like the one below are interleaved with
this text, and <tt>noweb</tt> pastes them together.  You can rebuild both this
document and an input file for the <a
href="https://github.com/jeredw/eniacsim">eniacsim</a> simulator with
<tt>make</tt>.  

<<File header>>=
# Generated by noweb, do not edit.  Use make to rebuild from sixty.nw.
# Input file for eniacsim (https://github.com/jeredw/eniacsim)
@

<p><b>Timings.</b>  Knowing how long an instruction takes might be
helpful to guess how it works, but LCS48 cycle timings are suspiciously low
for some instructions like <a href="#multiply"><tt>X</tt></a>.  The same
thing happens in modern datasheets when the marketing department gets hold of
them.  DU49 has more conservative timings despite its faster 6 cycle fetch, so
is likely more reliable.  DEC51 differs yet again but more closely matches
DU49.

<p>This implementation keeps execution time for 7-cycle instructions at 7
cycles and does its best to match the rest.

<p><b>Reserving A<sub>13</sub>.</b> Several instructions require
A<sub>13</sub> to be 0 before execution and guarantee it to be 0 after.  This
is indicated as

<blockquote>(13)0 -- (13)0</blockquote>

<p>in the before and after columns in LCS48 Section IV, notation that DU49
clarifies with an explicit footnote.  While by modern standards it's ugly that
this leaks into the ISA, presence or absence of this note is key information
for several instruction sequences.  DEC51 goes one step further and says what
will happen if A<sub>13</sub> is <em>not</em> 0 beforehand, which hints at
auxiliary <a href="#acc-inputs">inputs</a>.
<blockquote>The &ldquo;bad&rdquo; effects of not having 13 clear in the various
instructions that &ldquo;require&rdquo; it to be clear may occasionally prove
useful.</blockquote>
<p>It's unsurprising that programmers came to abuse this quirk in a way
reminiscent of <a
href="https://en.wikipedia.org/wiki/Illegal_opcode">illegal opcodes</a>.
Presumably future-proofing wasn't a major concern for ENIAC software, despite
&ldquo;an ever improving catalogue of sequences... available for
reference&rdquo;.

<p><b>Accumulator <a name="#acc-inputs">inputs</a>.</b> Many
instructions require shifting digits, and that must be done at accumulator
inputs.  There are 20&times;5 inputs, so you wouldn't expect this to be a
bottleneck, but the instruction set places a lot of pressure on A<sub>15</sub>
and A<sub>13</sub>.  Two of A<sub>13</sub> and A<sub>15</sub>'s ten inputs are
tied up for the multiplier, and most of the rest have implied connections to
support instructions that don't reserve A<sub>13</sub>.

<p>When A<sub>13</sub> is reserved, it's possible to stash A<sub>n</sub> in
A<sub>13</sub>, use one of A<sub>n</sub>'s inputs, and then transfer the answer
and restore A<sub>n</sub>.  For example, the LCS48 paragraph about
<tt>C.T.</tt> mentions using a shifter on A<sub>10</sub> to accomplish the
required PC shift this way.  This is corroborated in DEC51,
<blockquote>If 13 is not clear, its number will be subtracted from 10
(10-13&rarr;10) on the positive branch.</blockquote>

<p><b>Reusing programs.</b> A<sub>15</sub> and A<sub>13</sub> do so
much that it is vital to reuse their programs for multiple sequences.  This can
be accomplished either with pulse amplifiers or dummy programs.  Pulse
amplifiers are more convenient because dummy programs introduce an extra delay
cycle, but are scarce&mdash;LCS48 explicitly mentions 8 units with 11 channels
and claims all but 23 of them in Table 2.II (omitting alternate orders.)

<p>For dummy programs, apart from scarce accumulator transceivers, there are
six selective clear transceivers, and twenty unused constant transmitter
transceivers.  Those are so tempting that we put constants on a separate <a
href="#trunks">digit trunk</a> and trigger lots of spurious constant
transmission just to be able to reclaim them.

<h2>Implementation</h2>

<<*>>=
<<File header>>
<<Reset>>
<<Fetch sequence>>
<<Decode>>
<<Digit trunks>>
<<Pulse amplifiers>>
<<Instructions>>
@

<h3>Reset</h3>

<p>The initial clear sequence clears accumulators, including the PC, but not
the ft selector or order selector.  So we need to clear those as part of the
initiate sequence to begin fetch at a consistent place.

<<Reset>>=
# Initiate pulse triggers A-1
p i.Io A-1

# Pulse amplifiers clear order selector and ft selector
# (A-1 -> A-3, A-1 -> E-9)
p A-3 os.Ci

# Dummy program to start fetch next cycle
p A-1 a2.12i
s a2.op12 0
s a2.cc12 0
s a2.rp12 1
p a2.12o C-5
@ %def A-1

<h3>Fetch sequence</h3>

<p>Here we set up the 7-cycle instruction fetch sequence described in
LCS 48 &ldquo;II: Conversion of digit pulses to programming pulses&rdquo;.
Parts of the sequence are reused to fetch arguments for <tt>NxD</tt> so are
separately controllable, e.g. <tt>N6D</tt> triggers [[D-6]]&rarr;[[J-2]],
[[E-1]] but not [[C-5]], so it will read from the function table but not decode
a new instruction.

<p>The sequence is summarized in LCS48 Figure 2.2, which is redrawn as
implemented here with changes <s>crossed out</s>.

<table>
<tr>
<th>
<th>F.T. sel
<th>Order<br>sel
<th>10-stage<br>stepper
<th>Master<br>prog.
<th>Acc 6
<th>Acc 20
<th>FT I
<th>FT II
<th>FT III
<th>SC</th>

<tr>
<td>0
<td>[[E-1]] i#1
[[E-8]] di 
1&rarr;[[E-11]]
2&rarr;[[F-1]]
3&rarr;[[F-2]]
<td><td><td>
<td>[[J-2]]
 A01 
  [[E-9]]
<td>[[C-5]]
 <s>006</s>
 005
  [[E-10]]
<td><td><td><td>
<tr>
<td>1
<td>[[E-9]] <s>i#2</s>
 cdi
<td><td><td><td><td>|
<td>[[E-11]]
NC
 [[J-4]]
<td>[[F-1]]
NC
 [[J-4]]
<td>[[F-2]]
NC
 [[J-4]]
<td></td>

<tr>
<td>2
<td><td><td><td><td>J-4   
 A01
  [[F-3]]
<td>|<td>|<td>|<td>|<td></td>

<tr>
<td>3
<td><td>[[F-3]]
 CPP1
  [[F-4]]
<td><td><td><td>|<td>|<td>|<td>|<td>[[F-3]]
 001
  [[F-5]]

<tr>
<td>4
<td><td><td>[[F-5]]
 cdi
<td>[[F-5]]
 cdi
<td>[[F-4]]
 εC1
<s>[[F-5]]</s>
 <s>002</s>
  <s>[[G-8]]</s>
<td>|<td>|<td>|<td>|<td>[[F-5]]
 001
  [[G-8]]

<tr>
<td>5<td><td>[[G-8]]
 i
<td>* di
[[E-10]]
 i
<td>* di
<td><td>x<td>x<td>x<td>x<td>

<tr>
<td>6
<td><td><s>G-8</s>
 <s>i</s><td><s>[[E-10]]</s>
 <s>i</s><td>Xi
 CPP
  Xko<td><td><td><td><td><td>

<tr style="border-top: 3px solid #ccc; background: #eee;">
<td>0
<td><td><td><td>(Xko&rarr;[[C-5]])<td><td>[[C-5]]&hellip;<td><td><td><td>
</table>

<p>Cycle 0 decodes the hundreds digit of the PC (A<sub>6</sub>) to select one
of three function tables.  The function table read takes five cycles, with data
returning in cycle 5.  The order selector must thus multiplex data to the
decoder stepper direct inputs in cycle 5.  In cycle 6 the ten stage stepper
output triggers the correct MP stepper input, so that in cycle 7 &equiv; 0 the
MP output corresponding to the instruction and possibly [[C-5]] can be
asserted.

<h4>Changes</h4>

<ol>
<li>[[E-10]] just seems mistimed.  ETM X-6 is clear that for MP steppers,
<blockquote>A program pulse received at the end of addition time t...
sets the input flip-flop.  The normally negative output of this flip-flop then
opens gate 69 so that a CPP passes through at the end of addition time
t+1.</blockquote>  MP output is at the end of cycle 6, so the input from the
ten stage stepper must be setup at the end of cycle 5, which in turn means its
input needs to arrive at the end of cycle 4.
<li>It is unclear what [[E-9]] is for or what the annotation <tt>i#2</tt>
means.  The ft selector stepper needs to be cleared somehow, so assume it is
for that.
<li>If [[G-8]] is an output enable for the order selector, it is also late.
It's possible [[G-8]] was meant to step the order selector ring, and [[F-4]]
was meant to trigger when it is on the last stage?  In <tt>eniacsim</tt>, the
<a href="https://github.com/jeredw/eniacsim/blob/master/lib/units/ordersel.go">order
selector</a> is built so that [[F-3]] actually steps it, and [[F-4]] triggers
when it has overflowed; the <tt>i</tt> input just gates output digits.
<p>RIF has [[F-5]] trigger [[G-8]] one cycle later via a dummy program on SC#1.
</ol>

<h4>Code</h4>

<<Fetch sequence>>=
# Fetch 0: Select function table.
<<Fetch sequence: cycle 0>>
# Fetch 1: Initiate function table read.
<<Fetch sequence: cycle 1>>
# Fetch 2: Send function table argument.
<<Fetch sequence: cycle 2>>
# Fetch 3: Step order selector ring.
<<Fetch sequence: cycle 3>>
# Fetch 4: Clear decoder steppers and increment PC.
<<Fetch sequence: cycle 4>>
# Fetch 5: Decode instruction data.
<<Fetch sequence: cycle 5>>
# Fetch 6: Wait for MP decoder.
<<Fetch sequence: cycle 6>>
@

<h4>Fetch cycle 0</h4>
<<Fetch sequence: cycle 0>>=
# Select the FT to read.
# Decode E-8=0,1,2 into E-11, F-1, or F-2.
p E-1 sft.i
p E-8 sft.di
p sft.1o E-11
p sft.2o F-1
p sft.3o F-2

# Send PC on trunk 5.
p J-2 a6.5i
s a6.op5 A
s a6.cc5 0
s a6.rp5 1
p a6.5o E-9

# Await instruction data.
p C-5 a20.12i
s a20.op12 0
s a20.cc12 0
s a20.rp12 5
p a20.12o E-10
@ %def E-11 F-1 F-2 E-9 E-10

<h4>Fetch cycle 1</h4>

<p>Note that instructions use A-2 addressing; see the notes about the
<code><a href="#ft"> F.T.</a></code> instruction.

<<Fetch sequence: cycle 1>>=
# Clear FT selector for next fetch.
p E-9 sft.cdi

# Initiate instruction or operand read.
p E-11 f1.1i
s f1.op1 A-2
s f1.cl1 NC
s f1.rp1 1
p f1.NC J-4

p F-1 f2.1i
s f2.op1 A-2
s f2.cl1 NC
s f2.rp1 1
p f2.NC J-4

p F-2 f3.1i
s f3.op1 A-2
s f3.cl1 NC
s f3.rp1 1
p f3.NC J-4
@ %def J-4

<h4>Fetch cycle 2</h4>
<<Fetch sequence: cycle 2>>=
# Send value for FT argument.
# Note this is also used by the 6(11,10,9) and 6(8,7) sequences.
p J-4 a6.6i
s a6.op6 A
s a6.cc6 0
s a6.rp6 1
p a6.6o F-3
@ %def F-3

<h4>Fetch 3</h4>
<<Fetch sequence: cycle 3>>=
# Step the instruction ring counter.
p F-3 os.Ri
p os.Ro F-4  # overflow -> inc PC

# Dummy program to trigger Fetch 4.
p F-3 i.Ci4
p i.Co4 F-5
@ %def F-4 F-5

<h4>Fetch cycle 4</h4>

<p>LCS48 places both the PC increment triggered by [[F-4]] and the [[G-8]]
dummy program on A<sub>6</sub> in this cycle.  ETM doesn't clearly specify the
behavior of simultaneous programs on an accumulator, but warns against it, so
this is fishy.  It should probably work, though?  We follow RIF which places
the [[G-8]] dummy program on SC#1 instead.

<<Fetch sequence: cycle 4>>=
# Clear steppers prior to decode
p F-5 st.cdi
p F-5 p.Acdi
p F-5 p.Bcdi
p F-5 p.Ccdi
p F-5 p.Dcdi
p F-5 p.Ecdi
p F-5 p.Fcdi
p F-5 p.Gcdi
p F-5 p.Hcdi
p F-5 p.Jcdi
p F-5 p.Kcdi

# Increment PC if order selector wrapped
p F-4 a6.1i
s a6.op1 ε
s a6.cc1 C
# Dummy to enable order selector output next cycle.
p F-5 i.Ci1
p G-8 i.Co1
@ %def G-8

<h4>Fetch cycle 5</h4>
<<Fetch sequence: cycle 5>>=
# Order selector passes FT data.
p G-8 os.i

# Decode tens digit and trigger corresponding MP stepper input.
# Since only B-2 and B-5 are documented by available sources, just wire up
# the other ten stage stepper outputs directly.
p E-10 st.i
p F-6 st.di
p st.1o B-2
p B-2 p.Ai
p st.2o B-5
p B-5 p.Bi
p st.3o p.Ci
p st.4o p.Di
p st.5o p.Ei
p st.6o p.Fi
p st.7o p.Gi
p st.8o p.Hi
p st.9o p.Ji
p st.10o p.Ki

# Decode ones digit.
p E-2 p.Adi
p E-2 p.Bdi
p E-2 p.Cdi
p E-2 p.Ddi
p E-2 p.Edi
p E-2 p.Fdi
p E-2 p.Gdi
p E-2 p.Hdi
p E-2 p.Jdi
p E-2 p.Kdi

<<Fetch sequence: configure MP for decoding>>
@ %def B-2 B-5

<p>MP steppers must be set to use all 6 positions since we want to decode 0-5.
We don't want to use MP decades, but if the decade switches are set to zero,
they'll overflow every cycle and steppers will be free running&mdash;in
particular they'll increment during the cdi cycle.  So decade switches must be
nonzero.  <tt><i>X</i>i</tt> will trigger a decade counter increment, which
might cause a spurious step next cycle, but the correct output will still
trigger this cycle.

<<Fetch sequence: configure MP for decoding>>=
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6
# Set decade switches to nonzero values so that steppers don't cycle in between
# cdi and the decode cycle.
s p.d1s1 1
s p.d2s1 1
s p.d3s1 1
s p.d4s1 1
s p.d5s1 1
s p.d6s1 1
s p.d7s1 1
s p.d8s1 1
s p.d9s1 1
s p.d10s1 1
s p.d11s1 1
s p.d12s1 1
s p.d13s1 1
s p.d14s1 1
s p.d15s1 1
s p.d16s1 1
s p.d17s1 1
s p.d18s1 1
s p.d19s1 1
s p.d20s1 1
@

<h4>Fetch cycle 6</h4>
<<Fetch sequence: cycle 6>>=
# Waiting for MP decoder to propagate stepper input to output.
@

<h3>Decode</h3>

<p>Decode opcodes to program lines following LCS48 Table 2.I.

<p>LCS48 describes two slightly different instruction sets, a &ldquo;regular
code&rdquo; and an &ldquo;alternate code&rdquo; with seven variant
instructions.  Alternate instructions are annotated below as <em>n</em>a where
<em>n</em> is the opcode.

<p>The sample programs in LCS48 use the regular code, so that's what is wired
up here.  In some cases wiring for the alternate code is left present but
commented out.  DU49 seems to have merged the two instruction sets.

<<Decode>>=
<<Decode: xl>>
<<Decode: xt>>
<<Decode: arithmetic>>
<<Decode: alternate instructions>>
<<Decode: control flow>>
<<Decode: I/O>>
#p p.H2o      # Halt       (71)  NB doesn't decode to anything, so stops
p p.K2o C-3   # 18<->20    (91)  9 cycles
p p.K3o V-2   # 6(11,10,9) (92)
p p.K4o V-4   # 6(8,7)     (93)
@ %def C-3 V-2 V-4

<h4>x<sub>l</sub></h4>

<<Decode: xl>>=
p p.A2o S-1   # 1l  (01)
p p.A3o S-2   # 2l  (02)
p p.A4o S-3   # 3l  (03)
p p.A5o S-4   # 4l  (04)
p p.A6o S-5   # 5l  (05)
p p.B1o S-6   # 7l  (10)
p p.B2o L-7   # 8l  (11)
p p.B3o L-8   # 9l  (12)
p p.B4o L-9   # 10l (13)
p p.B5o L-10  # 11l (14)
p p.B6o L-11  # 12l (15)
p p.C1o C-7   # 13l (20)  NB a13 += a15, doesn't clear first
p p.C2o H-1   # 14l (21)
p p.C3o H-2   # 16l (22)
p p.C4o H-3   # 17l (23)
p p.C5o H-4   # 18l (24)
p p.C6o H-5   # 19l (25)
@ %def S-1 S-2 S-3 S-4 S-5 S-6 L-7 L-8 L-9 L-10 L-11 C-7 H-1 H-2 H-3 H-4 H-5

<h4>x<sub>t</sub></h4>

<<Decode: xt>>=
p p.D2o V-9   # 1t  (31)
p p.D3o S-7   # 2t  (32)
p p.D4o S-8   # 3t  (33)
p p.D5o S-9   # 4t  (34)
p p.D6o S-10  # 5t  (35)
p p.E1o S-11  # 7t  (40)
p p.E2o C-2   # 8t  (41)
p p.E3o L-1   # 9t  (42)
p p.E4o L-2   # 10t (43)
p p.E5o L-3   # 11t (44)
p p.E6o L-4   # 12t (45)
p p.F1o L-5   # 13t (50)  NB clears after sending
p p.F2o L-6   # 14t (51)
p p.F3o C-9   # 16t (52)
p p.F4o H-6   # 17t (53)
p p.F5o H-7   # 18t (54)
p p.G5o H-8   # 19t (64)
@ %def V-9 S-7 S-8 S-9 S-10 S-11 C-2 L-1 L-2 L-3 L-4 L-5 L-6 C-9 H-6 H-7 H-8

<h4>Arithmetic</h4>

<p><code>C</code> decodes into [[C-1]] which is the generic <code>xl</code>
program line for all listen orders.

<<Decode: arithmetic>>=
p p.A1o C-1   # C   (00)  (also the general xl)
p p.D1o E-5   # X   (30)  "15 cycles"
p p.F6o E-3   # ÷   (55)  ~75 cycles
p p.G1o B-1   # √   (60)  ~75 cycles
p p.G4o V-3   # M   (63)
p p.G6o H-10  # DS  (65)
p p.J6o C-10  # Sh' (85)  20 cycles
p p.K1o C-11  # Sh  (90)  20 cycles
@ %def E-5 E-3 B-1 C-10 C-11 V-3 H-10

<h4>Control flow</h4>

<<Decode: control flow>>=
p p.H6o G-2   # C.T.(75)  14/8 cycles
p p.H4o E-6   # 6R3 (73)  13 cycles
p p.H5o E-7   # 6R6 (74)  13 cycles
@ %def G-2 E-6 E-7

<h4>I/O</h4>

<<Decode: I/O>>=
p p.G2o O-1   # Pr. (61)  60 cards / min
p p.G3o O-2   # Rd. (62)  100 cards / min
p p.H3o H-11  # F.T.(72)  13 cycles
p p.H1o V-5   # N2D (70)  14 cycles
p p.K5o V-6   # N4D (94)  20 cycles
p p.K6o V-7   # N6D (95)  26 cycles
p p.J1o D-7   # AB  (80)
p p.J2o D-8   # CD  (81)
p p.J3o D-9   # EF  (82)
p p.J4o D-10  # GH  (83)
p p.J5o D-11  # JK  (84)
@ %def O-1 O-2 H-11 V-5 V-6 V-7 D-7 D-8 D-9 D-10 D-11

<h4>Alternate instructions</h4>

<<Decode: alternate instructions>>=
#p p.K2o C-8  # 20l (91a)
#p p.H4o E-4  # 6l  (73a) 9 cycles
#p p.H5o V-1  # 6t  (74a)
# Table 2.I has "H-0" for order 92a. Assume this is a typo for H-9 which is the
# only H-line missing, and makes sense from pulse amp grouping.
#p p.K3o H-9  # 20t  (92a)
#p p.K4o V-8  # N3D8 (93a) 20 cycles
#p p.K5o ???  # N3D6 (94a) 20 cycles
#p p.K6o ???  # N6D6 (95a) 26 cycles
@ %def C-8 E-4 V-1 H-9 V-8

<h3><a name=trunks>Digit trunks</a></h3>

<p>LCS48 has a note advising the reader to &ldquo;see digit tray
hook-up&rdquo;, so perhaps the author meant to include a chart with the report.
But sadly there isn't one.

<p>All LCS48 tells us explicitly is that for <code>1ℓ</code>, <tt>a1.α=2</tt>
and <tt>a15.A=2</tt>; and for <code>AB</code>, figure 3.2 has <tt>c.o=1</tt>,
<tt>a11.δ=1</tt>, and <tt>a15.β=1</tt>.  This last assignment overlaps with the
canonical multiplier correction wiring from ETM, which has the correction term
on <tt>a15.β</tt>, but it's plausible that's shared.

<p>RIF annotates order selector ouptut as II<sub>2</sub>, II<sub>1</sub>,
implying instructions are sent on trunk 2.
 
<h4>Reconstructed wiring</h4>

<p>Here is a chart of accumulator digit terminals used in this reconstruction,
and their connections.  The base number gives the digit trunk, and any
superscript or annotation indicates a connected adapter.

<table style="text-align:center">
<tr>
<th>
<th>A<sub>1</sub><br>
<th>A<sub>2</sub><br>
<th>A<sub>3</sub><br>
<th>A<sub>4</sub><br>Quot.
<th>A<sub>5</sub><br>Num
<th>A<sub>6</sub><br>PC
<th>A<sub>7</sub><br>Denom.
<th>A<sub>8</sub><br>Arg.
<th>A<sub>9</sub><br>Shift
<th>A<sub>10</sub><br>
<th>A<sub>11</sub><br>Ier
<th>A<sub>12</sub><br>Icand
<th>A<sub>13</sub><br>LHPP
<th>A<sub>14</sub><br>
<th>A<sub>15</sub><br>RHPP
<th>A<sub>16</sub><br>
<th>A<sub>17</sub><br>
<th>A<sub>18</sub><br>
<th>A<sub>19</sub><br>
<th>A<sub>20</sub><br>
<tr><td>α<td>2<td>2<td>2<td>10<td>2<td>2<td>2<td>2<td><a href="#11s">11*</a><td>2<td>2<td>2<td>6<td>2<td>7<td>2<td>2<td>2<td>2<td>2
<tr><td>β<td>1<td>1<td>1<td>2<td><td>1<td>1<td><td>2<td><a href="#5c">5<sup>c</sup></a><td><a href="#3s">3*</a><td>1<td>8=2<td>1<td>9=1<td>1<td>1<td>1<td>1<td>1
<tr><td>γ<td><a href="#5a">5<sup>a</sup></a><td><td><td>1<td>11=1<td><a href="#2a">2<sup>a</sup><td>10<td><td>1<td><a href="#2c">2<sup>c</sup></a><td><a href="#1f">1<sup>f</sup><td><td>1<td><td><a href="#4s">4*</a><td><td><td><a href="#2g">2<sup>g</sup></a><td><td><a href="#5d">5<sup>d</sup></a>
<tr><td>δ<td><a href="#5b">5<sup>b</sup></a><td>2<sup>+1</sup><td>2<sup>+2</sup><td>2<sup>+3</sup><td>2<sup>+4</sup><td><a href="#2b">2<sup>b</sup></a><td>2<sup>+5</sup><td><td>2<sup>-5</sup><td><a href="#5e">5<sup>e</sup></a><td>1<td><td><td>2<sup>-4</sup><td>5<td>2<sup>-3</sup><td>2<sup>-2</sup><td><a href="#2h">2<sup>h</sup></a><td>2<sup>-1</sup><td><a href="#2d">2<sup>d</sup></a>
<tr><td>ε<td><td>1<sup>-9</sup><td>1<sup>-8</sup><td>1<sup>-7</sup><td>1<sup>-6</sup><td>-<td>1<sup>-5</sup><td><td>1<sup>+5</sup><td><td><td><td><td>1<sup>+6</sup><td><td>1<sup>+7</sup><td>1<sup>+8</sup><td><td>1<sup>+9</sup><td>
<tr style="border-top: 3px solid #ccc">
<td>A<td>1<td>1<td>1<td>1<td>11=1<td>5<td>11=1<td>5<td>11=1<td>1<td>1<td>1<td>1<td>1<td>2<td>1<td>1<td>1<td>1<td>1
<tr>
<td>S<td>1<td><td><td><td><td><td>11=1<td><td><td>2<td>8=2<td>9=1<td>2<td><td><td><td><td>2<td><td>2
</table>

<p>Many other accumulator input assignments are implicit.  For example, since
A<sub>15</sub> is the multiplier RHPP, α is dedicated for that.  β is wired to
trunk 1.  A<sub>15</sub> has to be able to receive shifted function table data
for <code>F.T.</code>, so that's γ.  Assuming the function table argument is on
a separate trunk 5 to simplify fetch/execute overlap, A<sub>8</sub> must
transmit on that trunk for <code>F.T.</code>; then to support <code>8t</code>,
<tt>a15.δ=5</tt> (pulse amp wiring and <code>6t</code> timing also support
this).


<p>The most interesting choice is using two separate digit trunks for
communication between arithmetic accumulators.  Temporary accumulators with
lots of inputs mentioned in DEC51 often transmit subtractively to
A<sub>13</sub>, presumably via trunk 2 ≠ trunk 1.  In principle these register
transfers could happen in parallel with transfers on trunk 1.  But in practice
there is not much opportunity for this parallelism, and it's wasteful of
inputs.  This might just be wrong, or something that's only needed for the
expanded instruction set of DU49/DEC51.

<<Digit trunks>>=
#  1    most accumulators transmit on 1
#  2    most accumulators receive on 2
#  3    ft data A
#  4    ft data B
#  5    ft argument
#  6,7  multiplier partial product digits (exclusive)
#  8=2  multiplier correction terms (shared)
p 8 2
#  9=1  multiplier correction terms (shared)
p 9 1
#  10   divider/square rooter answer (exclusive)
#  11=1 divider/square rooter shift (shared)
p 11 1

<<Digit trunks: non-accumulator connections>>
<<Digit trunks: accumulator connections>>
<<Digit trunks: adapters>>
@

<h4>Non-accumulator connections</h4>

<<Digit trunks: non-accumulator connections>>=
# Trunk 1 - accumulators, constants
p 1 c.o     # Constant data for C.T.

# Trunk 2 - accumulators, instructions
p 2 os.o    # Instruction to decode, and immediate operand for NxD

# Trunk 3 - ft data A
p 3 os.A    # Data for fetch and F.T.
p 3 f1.A
p 3 f2.A
p 3 f3.A

# Trunk 4 - ft data B
p 4 os.B    # Data for fetch and F.T.
p 4 f1.B
p 4 f2.B
p 4 f3.B

# Trunk 5
p 5 f1.arg  # Argument for F.T., PC
p 5 f2.arg
p 5 f3.arg

# Trunk 6/7 - multiplier partial products
p 6 m.lhppI
p 7 m.rhppI

# Trunk 10 - divider/square rooter answer
p 10 d.ans
@

<h4>Accumulator connections</h4>

<<Digit trunks: accumulator connections>>=
# Accumulator 1
p 2 a1.α
p 1 a1.β
p ad.permute.4 a1.γ  # For 6(11,10,9)
p ad.permute.6 a1.δ  # For 6(8,7)
p 1 a1.A
p 1 a1.S  # Save to a13

# Accumulator 2
p 2 a2.α
p 1 a2.β
p ad.permute.20 a2.δ  # Sh  01 answer
p ad.permute.30 a2.ε  # Sh' 01 residual
p 1 a2.A

# Accumulator 3
p 2 a3.α
p 1 a3.β
p ad.permute.21 a3.δ  # Sh  02 answer
p ad.permute.31 a3.ε  # Sh' 02 residual
p 1 a3.A

# Accumulator 4 - quotient
p 10 a4.α  # Divider/square rooter answer
p 2 a4.β
p 1 a4.γ
p ad.permute.22 a4.δ  # Sh  03 answer
p ad.permute.32 a4.ε  # Sh' 03 residual
p 1 a4.A

# Accumulator 5 - numerator
p 2 a5.α
p 11 a5.γ  # Divider shift (1=11)
p ad.permute.23 a5.δ  # Sh  04 answer
p ad.permute.33 a5.ε  # Sh' 04 residual
p 11 a5.A  # Divider shift (1=11)

# Accumulator 6 - PC
p 2 a6.α
p 1 a6.β
p ad.permute.3 a6.γ  # For 6(11,10,9)
p ad.permute.5 a6.δ  # For 6(8,7)
#p 0 a6.ε  # NB ε is used as a dummy for increment
p 5 a6.A

# Accumulator 7 - denominator
p 2 a7.α
p 1 a7.β
p 10 a7.γ  # Divider answer
p ad.permute.24 a7.δ  # Sh  05 answer
p ad.permute.34 a7.ε  # Sh' 05 residual
p 11 a7.A  # Divider shift (1=11)
p 11 a7.S  # Divider shift (1=11)

# Accumulator 8 - F.T. argument
p 2 a8.α
p 5 a8.A

# Accumulator 9 - shift
p ad.s.1.1 a9.α
p 2 a9.β
p 1 a9.γ
p ad.permute.29 a9.δ  # Sh  95 answer
p ad.permute.39 a9.ε  # Sh' 95 residual
p 11 a9.A  # Divider shift (1=11)

# Accumulator 10
p 2 a10.α
p ad.permute.7 a10.β  # For 6R3
p ad.permute.8 a10.γ  # For 6R3
p ad.permute.11 a10.δ  # For C.T.
p 1 a10.A
p 2 a10.S  # Save to a13

# Accumulator 11 - ier
p 2 a11.α
p ad.permute.1 a11.β  # F.T. data A
p ad.permute.12 a11.γ  # For DS
p 1 a11.δ
p 1 a11.A
p 8 a11.S  # Multiplier correction (8=2)

# Accumulator 12 - icand
p 2 a12.α
p 1 a12.β
p 1 a12.A
p 9 a12.S  # Multiplier correction (9=1)

# Accumulator 13 - LHPP
p 6 a13.α  # Multiplier partial product
p 8 a13.β  # Multiplier correction (8=2)
p 1 a13.γ
p 1 a13.A
p 2 a13.S  # Restore temporaries

# Accumulator 14
p 2 a14.α
p 1 a14.β
p ad.permute.28 a14.δ  # Sh  94 answer
p ad.permute.38 a14.ε  # Sh' 94 residual
p 1 a14.A

# Accumulator 15
p 7 a15.α  # Multiplier partial product
p 9 a15.β  # Multiplier correction (9=1)
p ad.permute.2 a15.γ  # F.T. data B
p 5 ad.δ  # For 8t
p 2 a5.A

# Accumulator 16
p 2 a16.α
p 1 a16.β
p ad.permute.27 a16.δ  # Sh  93 answer
p ad.permute.37 a16.ε  # Sh' 93 residual
p 1 a16.A

# Accumulator 17
p 2 a17.α
p 1 a17.β 
p ad.permute.26 a17.δ  # Sh  92 answer
p ad.permute.36 a17.ε  # Sh' 92 residual
p 1 a17.A

# Accumulator 18
p 2 a18.α
p 1 a18.β
p ad.permute.13 a18.γ  # For N4D
p ad.permute.14 a18.δ  # For N6D
p 1 a18.A
p 2 a18.S  # Save to a13

# Accumulator 19
p 2 a19.α
p 1 a19.β
p ad.permute.25 a19.δ  # Sh  91 answer
p ad.permute.35 a19.ε  # Sh' 91 residual
p 1 a19.A

# Accumulator 20
p 2 a20.α
p 1 a20.β
p ad.permute.9 a20.γ  # For 6R6
p ad.permute.10 a20.δ  # For 6R6
p 1 a20.A
p 2 a20.S  # Save to a13
@

<h4>Adapters</h4>

<p><b><a name="3s">3*</b>.  Shift function table output A digits to left.

<<Digit trunks: adapters>>=
# Function table output A, shifted to the left for F.T.
p 3 ad.permute.1
s ad.permute.1 11,6,5,4,3,2,1,0,0,0,0
@ %def ad.permute.1

<p><b><a name="4s">4*</a></b>.  Shift function table output B
digits to left.

<<Digit trunks: adapters>>=
# Function table output B, shifted to the left for F.T.
p 4 ad.permute.2
s ad.permute.2 11,6,5,4,3,2,1,0,0,0,0
@ %def ad.permute.2

<p><b><a name="5a">5<sup>a</sup></a>, <a name="2a">2<sup>a</sup></a></b>.
Shift A<sub>15</sub>(11,2,1) to the top two digits and back for
<code>6(11,10,9)</code>.

<<Digit trunks: adapters>>=
# For 6(11,10,9).
p 2 ad.permute.3
s ad.permute.3 11,2,1,0,0,0,0,0,0,0,0
p 5 ad.permute.4
s ad.permute.4 11,0,0,0,0,0,0,0,0,10,9
@ %def ad.permute.3 ad.permute.4

<p><b><a name="5b">5<sup>b</sup></a>, <a name="2b">2<sup>b</sup></a></b>.
Shift A<sub>15</sub>(2,1) to positions 8,7 and back for <code>6(8,7)</code>.

<<Digit trunks: adapters>>=
# For 6(8,7).
p 2 ad.permute.5
s ad.permute.5 0,0,0,2,1,0,0,0,0,0,0
p 5 ad.permute.6
s ad.permute.6 0,0,0,0,0,0,0,0,0,8,7
@ %def ad.permute.5 ad.permute.6

<p><b><a name="5c">5<sup>c</sup></a>, <a name="2c">2<sup>c</sup></a></b>.
Replace digits 3-1 of A<sub>6</sub> with A<sub>15</sub> for <code>6R3</code>.

<<Digit trunks: adapters>>=
# For 6R3.
p 5 ad.permute.7
s ad.permute.7 11,10,9,8,7,6,5,4,0,0,0
p 2 ad.permute.8
s ad.permute.8 0,0,0,0,0,0,0,0,3,2,1
@ %def ad.permute.7 ad.permute.8

<p><b><a name="5d">5<sup>d</sup></a>, <a name="2d">2<sup>d</sup></a></b>.
Replace digits 6-1 of A<sub>6</sub> with A<sub>15</sub> for <code>6R6</code>.

<<Digit trunks: adapters>>=
# For 6R6.
p 5 ad.permute.9
s ad.permute.9 11,10,9,8,7,0,0,0,0,0,0
p 2 ad.permute.10
s ad.permute.10 0,0,0,0,0,6,5,4,3,2,1
@ %def ad.permute.9 ad.permute.10

<p><b><a name="5e">5<sup>e</sup></a></b>.  Shift new PC digits from 6-4 to 3-1
in A<sub>6</sub> for <code>C.T.</code>

<<Digit trunks: adapters>>=
# For C.T., shift a6 digits 6-4 to position 3-1.
p 5 ad.permute.11
s ad.permute.11 11,10,9,8,7,0,0,0,6,5,4
@ %def ad.permute.11

<p><b><a name="1f">1<sup>f</sup></a></b>.  Drop sign for DS.

<<Digit trunks: adapters>>=
# Delete sign for DS
p 1 ad.permute.12
s ad.permute.12 0,10,9,8,7,6,5,4,3,2,1
@ %def ad.permute.12

<p><b><a name="2g">2<sup>g</sup></a>, <a name="2h">2<sup>h</sup></a></b>.
Shifts for <code>N4D</code> and <code>N6D</code> digits.

<<Digit trunks: adapters>>=
# Shift for N4D.
p 2 ad.permute.13
s ad.permute.13 0,0,0,0,0,0,0,2,1,0,0
# Shift for N6D.
p 2 ad.permute.14
s ad.permute.14 0,0,0,0,0,2,1,0,0,0,0
@ %def ad.permute.13 ad.permute.14

<p><b><a name="11s">11*</a></b>.  <tt>eniacsim</tt> requires this adapter for
its divider wiring.  ETM doesn't seem to mention it, so it's unclear if this is
a simulator quirk.

<<Digit trunks: adapters>>=
# For divider shifting
p 11 ad.s.1.1
@ %def ad.s.1.1

<p><b>1<sup>s</sup>, 2<sup>s</sup></b>.  <code>Sh</code> and <code>Sh'</code>
need a whole slew of adapters (<a href="#shifts">more discussion</a>.)

<<Digit trunks: adapters>>=
# Left shift adapters for Sh on a15.
p 2 ad.permute.20
s ad.permute.20 11,9,8,7,6,5,4,3,2,1,0       # << 1
p 2 ad.permute.21                            
s ad.permute.21 11,8,7,6,5,4,3,2,1,0,0       # << 2
p 2 ad.permute.22                            
s ad.permute.22 11,7,6,5,4,3,2,1,0,0,0       # << 3
p 2 ad.permute.23                            
s ad.permute.23 11,6,5,4,3,2,1,0,0,0,0       # << 4
p 2 ad.permute.24                            
s ad.permute.24 11,5,4,3,2,1,0,0,0,0,0       # << 5
# Right arithmetic shift adapters for Sh on a15.
p 2 ad.permute.25
s ad.permute.25 11,11,10,9,8,7,6,5,4,3,2     # >> 1
p 2 ad.permute.26
s ad.permute.26 11,11,11,10,9,8,7,6,5,4,3    # >> 2
p 2 ad.permute.27
s ad.permute.27 11,11,11,11,10,9,8,7,6,5,4   # >> 3
p 2 ad.permute.28
s ad.permute.28 11,11,11,11,11,10,9,8,7,6,5  # >> 4
p 2 ad.permute.29
s ad.permute.29 11,11,11,11,11,11,10,9,8,7,6 # >> 5
@ %def ad.permute.20 ad.permute.21 ad.permute.22 ad.permute.23 ad.permute.24 ad.permute.25 ad.permute.26 ad.permute.27 ad.permute.28 ad.permute.29

<<Digit trunks: adapters>>=
# Sh' opposite of left shifts.
p 1 ad.permute.30
s ad.permute.30 11,11,11,11,11,11,11,11,11,11,10  # >> 9
p 1 ad.permute.31
s ad.permute.31 11,11,11,11,11,11,11,11,11,10,9   # >> 8
p 1 ad.permute.32
s ad.permute.32 11,11,11,11,11,11,11,11,10,9,8    # >> 7
p 1 ad.permute.33
s ad.permute.33 11,11,11,11,11,11,11,10,9,8,7     # >> 6
p 1 ad.permute.34
s ad.permute.34 11,11,11,11,11,11,10,9,8,7,6      # >> 5
# Sh' opposite of right shifts.
p 1 ad.permute.35
s ad.permute.35 11,1,0,0,0,0,0,0,0,0,0            # << 9
p 1 ad.permute.36
s ad.permute.36 11,2,1,0,0,0,0,0,0,0,0            # << 8
p 1 ad.permute.37
s ad.permute.37 11,3,2,1,0,0,0,0,0,0,0            # << 7
p 1 ad.permute.38
s ad.permute.38 11,4,3,2,1,0,0,0,0,0,0            # << 6
p 1 ad.permute.39
s ad.permute.39 11,5,4,3,2,1,0,0,0,0,0            # << 5
@ %def ad.permute.30 ad.permute.31 ad.permute.32 ad.permute.33 ad.permute.34 ad.permute.35 ad.permute.36 ad.permute.37 ad.permute.38 ad.permute.39

<<Digit trunks: adapters>>=
# Special digit adapters
# E-8 is the third digit of a6 or a8 from trunk 5.
p 5 ad.dp.1.3
p ad.dp.1.3 E-8
# E-2 selects the ones digit of the order from trunk 2.
p 2 ad.dp.2.1
p ad.dp.2.1 E-2
# F-6 selects the tens digit of the order from trunk 2.
p 2 ad.dp.3.2
p ad.dp.3.2 F-6
@ %def E-8 E-2 F-6

<h3>Pulse amplifiers</h3>

<p>LCS48 Table 2.II illustrates how a tree of pulse amplifiers is used to
combine order decode lines into common control signals.  For example, all the
<code>xl</code> instructions share a sequence controlled by [[C-1]], with their
separate behavior controlled by individual decode lines.

<<Pulse amplifiers>>=
# Box 1: Listen orders (xl) -> C-1
# Note that C-1 is also the encoding for 00 (C) which clears a15.
# 6l needs special handling.
p pa.1.sa.1  S-1  # 1l
p pa.1.sb.1  C-1
p pa.1.sa.2  S-2  # 2l
p pa.1.sb.2  C-1
p pa.1.sa.3  S-3  # 3l
p pa.1.sb.3  C-1
p pa.1.sa.4  S-4  # 4l
p pa.1.sb.4  C-1
p pa.1.sa.5  S-5  # 5l
p pa.1.sb.5  C-1
p pa.1.sa.6  S-6  # 7l
p pa.1.sb.6  C-1
p pa.1.sa.7  L-7  # 8l
p pa.1.sb.7  C-1
p pa.1.sa.8  L-8  # 9l
p pa.1.sb.8  C-1
p pa.1.sa.9  L-9  # 10l
p pa.1.sb.9  C-1
p pa.1.sa.10 L-10 # 11l
p pa.1.sb.10 C-1
p pa.1.sa.11 L-11 # 12l
p pa.1.sb.11 C-1
p pa.2.sa.1  C-7  # 13l
p pa.2.sb.1  C-1
p pa.2.sa.2  H-1  # 14l
p pa.2.sb.2  C-1
p pa.2.sa.3  H-2  # 16l
p pa.2.sb.3  C-1
p pa.2.sa.4  H-3  # 17l
p pa.2.sb.4  C-1
p pa.2.sa.5  H-4  # 18l
p pa.2.sb.5  C-1
p pa.2.sa.6  H-5  # 19l
p pa.2.sb.6  C-1
#p pa.x.sa.y  C-8  # 20l
#p pa.x.sb.y  C-1
@ %def C-1

<p>LCS48 Table 2.II seems to mention e.g. <tt>U-9</tt>, but there is no other
mention of the <tt>U</tt> trunk.  From Table 2.I, it's pretty clear this ought
to be [[V-9]], so assume the script font here just has <tt>V</tt>s that look
like <tt>U</tt>s.

<<Pulse amplifiers>>=
# Box 2: Talk orders (xt) -> D-3
# 6t and 8t need special handling because a6 and a8 transmit on a separate
# trunk to address the function table.
p pa.2.sa.7  V-9  # 1t
p pa.2.sb.7  D-3
p pa.2.sa.8  S-7  # 2t
p pa.2.sb.8  D-3
p pa.2.sa.9  S-8  # 3t
p pa.2.sb.9  D-3
p pa.2.sa.10 S-9  # 4t
p pa.2.sb.10 D-3
p pa.2.sa.11 S-10 # 5t
p pa.2.sb.11 D-3
p pa.3.sa.1  S-11 # 7t
p pa.3.sb.1  D-3
p pa.3.sa.2  L-1  # 9t
p pa.3.sb.2  D-3
p pa.3.sa.3  L-2  # 10t
p pa.3.sb.3  D-3
p pa.3.sa.4  L-3  # 11t
p pa.3.sb.4  D-3
p pa.3.sa.5  L-4  # 12t
p pa.3.sb.5  D-3
p pa.3.sa.6  L-5  # 13t
p pa.3.sb.6  D-3
p pa.3.sa.7  L-6  # 14t
p pa.3.sb.7  D-3
p pa.3.sa.8  C-9  # 16t
p pa.3.sb.8  D-3
p pa.3.sa.9  H-6  # 17t
p pa.3.sb.9  D-3
p pa.3.sa.10 H-7  # 18t
p pa.3.sb.10 D-3
p pa.3.sa.11 H-8  # 19t
p pa.3.sb.11 D-3
#p pa.x.sa.y  H-9  # 20t
#p pa.x.sb.y  D-3
@ %def D-3

<<Pulse amplifiers>>=
# Box 3: Constant transfers (uv) -> D-4
p pa.4.sa.1  D-7  # AB
p pa.4.sb.1  D-4
p pa.4.sa.2  D-8  # CD
p pa.4.sb.2  D-4
p pa.4.sa.3  D-9  # EF
p pa.4.sb.3  D-4
p pa.4.sa.4  D-10 # GH
p pa.4.sb.4  D-4
p pa.4.sa.5  D-11 # JK
p pa.4.sb.5  D-4
@ %def D-4

<<Pulse amplifiers>>=
# Box 4: Misc remaining 7 cycle ops (a1tmp) -> D-5
# These instructions use a1 as a temporary.
p pa.4.sa.6 V-2  # 6(11,10,9)
p pa.4.sb.6 D-5
p pa.4.sa.7 V-3  # M
p pa.4.sb.7 D-5
p pa.4.sa.8 V-4  # 6(8,7)
p pa.4.sb.8 D-5
@ %def D-5

<<Pulse amplifiers>>=
# Talk or constant transfers -> B-3
# B-3 triggers a15 to receive on trunk 1.
p pa.4.sa.9 D-3  # xt
p pa.4.sb.9 B-3
p pa.4.sa.10 D-4  # uv
p pa.4.sb.10 B-3
# Dual of constant transfers -> J-3
p pa.4.sa.11 D-4  # uv
p pa.4.sb.11 J-3
# Dual of a1tmp -> B-4
p pa.5.sa.1 D-5  # a1tmp
p pa.5.sb.1 B-4
@ %def B-3 B-4 J-3

<p>The most important common control signals are [[C-5]] and its
&ldquo;duals&rdquo; [[D-6]], [[J-2]], and [[E-1]], which control aspects of the
fetch and decode sequence.  7-cycle instructions re-assert [[C-5]] through
pulse amplifiers directly on decode.  Longer duration orders and transfers need
separate wiring to trigger [[C-5]].

<<Pulse amplifiers>>=
# C-5 triggers fetching _and decoding_ another instruction.
# C-1 (xl), D-3 (xt), D-4 (uv), D-5 (a1tmp) as well as C-2 (8t), V-1 (6t in
# alternate code), and H-10 (DS) all do so immediately upon decode.
p pa.5.sa.2 C-1  # xl
p pa.5.sb.2 C-5
p pa.5.sa.3 D-3  # xt
p pa.5.sb.3 C-5
p pa.5.sa.4 D-4  # uv
p pa.5.sb.4 C-5
p pa.5.sa.5 D-5  # a1tmp
p pa.5.sb.5 C-5
p pa.5.sa.6 C-2  # 8t
p pa.5.sb.6 C-5
#p pa.x.sa.y V-1  # 6t
#p pa.x.sb.y C-5
p pa.5.sa.7 H-10 # DS
p pa.5.sb.7 C-5
@ %def C-5

<<Pulse amplifiers>>=
# D-6 triggers the fetch sequence separately from decode.
p pa.5.sa.8 D-1  # N2D triggered from N4D/N6D
p pa.5.sb.8 D-6
p pa.5.sa.9 C-6  # N2D/N4D/N6D/N3D8 use fetch
p pa.5.sb.9 D-6
p pa.5.sa.10 D-2  # N4D triggered from N6D
p pa.5.sb.10 D-6
p pa.5.sa.11 C-5  # fetch+decode -> fetch
p pa.5.sb.11 D-6
p pa.6.sa.1 C-11 # Sh/Sh' take a shift amount
p pa.6.sb.1 D-6
@ %def D-6

<<Pulse amplifiers>>=
# J-2 and E-1 are duals of D-6
p pa.6.sa.2 D-6
p pa.6.sb.2 J-2  # PC update sequence
p pa.6.sa.3 D-6
p pa.6.sb.3 E-1  # FT read sequence
@ %def J-2 E-1

<<Pulse amplifiers>>=
# C-6 is {N2D,N4D,N6D,N3D8} - instructions that use a18 temporary.
p pa.6.sa.4 V-5  # N2D
p pa.6.sb.4 C-6
p pa.6.sa.5 V-7  # N6D
p pa.6.sb.5 C-6
#p pa.x.sa.y V-8   # N3D8
#p pa.x.sb.y C-6
p pa.6.sa.6 V-6  # N4D
p pa.6.sb.6 C-6

# D-1 is dual of N2D, also triggered by N4D sequence.
p pa.6.sa.7 V-5  # N2D
p pa.6.sb.7 D-1
# D-2 is dual of N4D, also triggered by N6D sequence.
p pa.6.sa.8 V-6  # N4D
p pa.6.sb.8 D-2
@ %def C-6 D-1 D-2

<<Pulse amplifiers>>=
# This connection is given in table 2.II without context.
# It's useful for the a1tmp sequence, so use it for that.
p pa.6.sa.9 C-4  # cycle 8 of a1tmp instructions
p pa.6.sb.9 J-1  # a15 send and clear

# Note C-11 is also the encoding for Sh.
p pa.6.sa.10 C-10 # Sh'
p pa.6.sb.10 C-11 # Sh

#p pa.x.sa.y C-8  # 20l
#p pa.x.sb.y K-11
@

<p>As helpful as LCS48 Table 2.II is, it's probably not comprehensive.  Pulse
amplifiers are so useful for conserving program inputs that it seems likely all
channels would have been used.  If we omit those for alternate instructions,
there are a luxurious 23 spare for this reconstruction.

<<Pulse amplifiers>>=
# Reset sequence
p pa.6.sa.11 A-1   # initiate pulse
p pa.6.sb.11 A-3   # clear order selector
p pa.7.sa.1  A-1   # initiate pulse
p pa.7.sb.1  E-9   # clear ft selector
@ %def A-3

<<Pulse amplifiers>>=
# a1tmp: Trigger a13 receive
p pa.7.sa.2 D-5   # a1tmp
p pa.7.sb.2 B-10   # a13 receive
# a1tmp: Trigger a13 send
p pa.7.sa.3 T-8    # a1tmp+11
p pa.7.sb.3 B-11    # a13 send and clear

# X: Trigger a15 to receive correction term
p pa.7.sa.5 M-3   # X+19
p pa.7.sb.5 B-3   # a15 receive correction term
# X: Trigger a15 to receive partial product
p pa.7.sa.6 M-4   # X+20
p pa.7.sa.6 B-11  # a13 send and clear
p pa.7.sa.7 M-4   # X+20
p pa.7.sb.7 B-3   # a15 receive lhpp

# ÷: Save lots of temporaries
p pa.7.sa.8 E-3   # ÷
p pa.7.sb.8 B-10   # a13 receive a4

p pa.7.sa.9 R-1   #
p pa.7.sb.9 J-1   # a15 send and clear
p pa.7.sa.10 R-2   #
p pa.7.sb.10 B-3   # a15 receive a9
p pa.7.sa.11 R-4   #
p pa.7.sb.11 J-1   # a15 send and clear

@

<h3>Instruction sequences</h3>

<<Instructions>>=
<<Instructions: xl>>
<<Instructions: xt>>
<<Instructions: constant>>
<<Instructions: a1-based>>
<<Instructions: multiply>>
<<Instructions: divide/square root>>
<<Instructions: DS>>
<<Instructions: NxD>>
<<Instructions: F.T.>>
<<Instructions: Pr.>>
<<Instructions: Rd.>>
@

<h4><a name=xl>xl (and C)</a></h4>

<pre>
  7. aL:AC1           # Clear aL [1]
   * a13:001          # ... except a13
  8. a15:AC1, aL:α01  # Receive a15 [2]
</pre>

<p><code>C</code> is just <code>xl</code> with no accumulator transmitting to
replace the value in A<sub>15</sub>.

<<Instructions: xl>>=
# xl instruction
# xl cycle 7: Clear aL
<<Instructions: xl cycle 7>>
# xl cycle 8: Receive from a15
<<Instructions: xl cycle 8>>
@

<p>[[C-1]] from pulse amplifiers triggers the second, A<sub>15</sub> cycle of
<code>xl</code> which is the same for each listen instruction.

<<Instructions: xl cycle 7>>=
# Dummy program to delay C-1->J-1, i.e. xl->a15 send.
# Figure 3.3 has this on the constant unit.  Note that this puts junk on
# trunk 1 during xl cycle 7 and conflicts with a1:AC1.
p C-1 c.3i
p c.3o J-1

# Clear listener
# 1l
p S-1 a1.5i
s a1.op5 A  # NB this is AC1 in Figure 3.3 not 0C1.
s a1.cc5 C
s a1.rp5 1
p a1.5o O-8  # O-8 is given in Figure 3.3.
# To conserve program lines, wire aN.5o directly to aN.1i for N>1.  In practice
# this would have been done with U cables (ETM XI-8).
# 2l
p S-2 a2.5i
s a2.op5 A
s a2.cc5 C
s a2.rp5 1
p a2.5o a2.1i
# 3l
p S-3 a3.5i
s a3.op5 A
s a3.cc5 C
s a3.rp5 1
p a3.5o a3.1i
# 4l
p S-4 a4.5i
s a4.op5 A
s a4.cc5 C
s a4.rp5 1
p a4.5o a4.1i
# 5l
p S-5 a5.5i
s a5.op5 A
s a5.cc5 C
s a5.rp5 1
p a5.5o a5.1i
# 6l = E-4 is not implemented
# 7l 
p S-6 a7.5i
s a7.op5 A
s a7.cc5 C
s a7.rp5 1
p a7.5o a7.1i
# 8l
p L-7 a8.5i
s a8.op5 A
s a8.cc5 C
s a8.rp5 1
p a8.5o a8.1i
# 9l
p L-8 a9.5i
s a9.op5 A
s a9.cc5 C
s a9.rp5 1
p a9.5o a9.1i
# 10l
p L-9 a10.5i
s a10.op5 A
s a10.cc5 C
s a10.rp5 1
p a10.5o a10.1i
# 11l
p L-10 a11.5i
s a11.op5 A
s a11.cc5 C
s a11.rp5 1
p a11.5o a11.1i
# 12l
p L-11 a12.5i
s a12.op5 A
s a12.cc5 C
s a12.rp5 1
p a12.5o a12.1i
# 13l: Note that 13l does a13 += a15 rather than a13 = a15
p C-7 a13.5i
s a13.op5 0
s a13.cc5 0
s a13.rp5 1
p a13.5o a13.1i
# 14l
p H-1 a14.5i
s a14.op5 A
s a14.cc5 C
s a14.rp5 1
p a14.5o a14.1i
# 16l
p H-2 a16.5i
s a16.op5 A
s a16.cc5 C
s a16.rp5 1
p a16.5o a16.1i
# 17l
p H-3 a17.5i
s a17.op5 A
s a17.cc5 C
s a17.rp5 1
p a17.5o a17.1i
# 18l 
p H-4 a18.5i
s a18.op5 A
s a18.cc5 C
s a18.rp5 1
p a18.5o a18.1i
# 19l
p H-5 a19.5i
s a19.op5 A
s a19.cc5 C
s a19.rp5 1
p a19.5o a19.1i
# 20l = C-8 is not implemented
@ %def J-1 O-8

<p>[[J-1]] which triggers <code>a15:AC1</code> is heavily reused.

<<Instructions: xl cycle 8>>=
# a15 send and clear
p J-1 a15.1i
s a15.op1 A
s a15.cc1 C

# Receive from a15
p O-8 a1.1i
s a1.op1 α
# aN.1i for N>1 is wired up directly in xl cycle 7
s a2.op1 α
s a3.op1 α
s a4.op1 β
s a5.op1 α
# 6l is not implemented
s a7.op1 α
s a8.op1 α
s a9.op1 β
s a10.op1 α
s a11.op1 α
s a12.op1 α
s a13.op1 β
s a14.op1 α
s a16.op1 α
s a17.op1 α
s a18.op1 α
s a19.op1 α
# 20l is not implemented
@

<h4><a name=xt>xt</a></h4>

<pre>
  7. aT:A01, a15:β01  # a15 receive aT
   * a13:AC1          # ... for a13 only, send and clear
</pre>
<p><code>8t</code> is a special case because <code>a8.A</code> is connected to
digit trunk 5 so needs a separate program on A<sub>15</sub>.  [[B-3]] which
triggers <code>a15:0β1</code> is heavily reused.

<<Instructions: xt>>=
# xt instruction
# Cycle 7: a15 receive from aX
p B-3 a15.2i
s a15.op2 β
# Special case for 8t: a15 receive on trunk 5
p C-2 a15.3i
s a15.op3 δ

# 1t
p V-9 a1.2i
s a1.op2 A
p S-7 a2.2i
s a2.op2 A
# 3t
p S-8 a3.2i
s a3.op2 A
# 4t
p S-9 a4.2i
s a4.op2 A
# 5t
p S-10 a5.2i
s a5.op2 A
# 6t = V-1 is not implemented
# 7t
p S-11 a7.2i
s a7.op2 A
# 8t
p C-2 a8.2i
s a8.op2 A
# 9t
p L-1 a9.2i
s a9.op2 A
# 10t
p L-2 a10.2i
s a10.op2 A
# 11t
p L-3 a11.2i
s a11.op2 A
# 12t
p L-4 a12.2i
s a12.op2 A
# 13t: Uniquely, 13t clears after sending
p L-5 a13.2i
s a13.op2 A
s a13.cc2 C
# 14t
p L-6 a14.2i
s a14.op2 A
# 16t
p C-9 a16.2i
s a16.op2 A
# 17t
p H-6 a17.2i
s a17.op2 A
# 18t
p H-7 a18.2i
s a18.op2 A
# 19t
p H-8 a19.2i
s a19.op2 A
@

<h4><a name="uv">AB/CD/EF/GH/JK</a></h4>

<p><code>AB</code> is one of two instructions with a sequence chart in LCS48,
figure 3.2.  There is nothing very surprising.
<pre>
  7. Blr, a15:β01  # Receive B digits in a15
  8. Alr, a11:δ01  # Receive A digits in a11
</pre>

<<Instructions: constant>>=
# AB/CD/EF/GH/JK instructions
# Constant cycle 7: right digits to a15
<<Instructions: constant cycle 7>>
# Constant cycle 8: left digits to a11
<<Instructions: constant cycle 8>>
@

<<Instructions: constant cycle 7>>=
# (Pulse amps trigger B-3 to add the constant to a15.)
p D-7 c.1i    # AB
s c.s1 Blr
p c.1o c.2i
p D-8 c.7i    # CD
s c.s7 Dlr
p c.7o c.8i
p D-9 c.13i   # EF
s c.s13 Flr
p c.13o c.14i
p D-10 c.19i  # GH
s c.s19 Hlr
p c.19o c.20i
p D-11 c.25i  # JK
s c.s25 Klr
p c.25o c.26i
# Clear a11 to receive a constant next cycle.
p J-3 a11.6i
s a11.op6 0
s a11.cc6 C
s a11.rp6 1
p a11.6o T-6
@ %def T-6

<<Instructions: constant cycle 8>>=
# Receive constant digits.
p T-6 a11.3i
s a11.op3 δ
# c.2i, c.8i, ... are connected directly from c.1o, c.7o, etc.
s c.s2 Alr
s c.s8 Clr
s c.s14 Elr
s c.s20 Glr
s c.s26 Jlr
@

<h4>6(11,10,9) and 6(8,7) and M</h4>

<p><code>M</code> is grouped with the <code>6(...)</code> instructions via the
pulse amplifier connection [[D-5]], presumably because all use A<sub>1</sub>
inputs.  They all share most of the same sequence.

<p>The <code>6(...)</code> instructions are listed as 7 cycles in LCS48 but as
10 in DU49.  They can overlap the fetch sequence in LCS48 at least, but care is
needed to avoid contention because A<sub>6</sub> is also the PC.

<p><code>6(11,10,9)</code> was renamed <code>6<sub>1</sub></code> in DEC51, and
has side-effect (1+13&rarr;1). <code>6(8,7)</code> was renamed
<code>6<sub>2</sub></code> and also has (1+13&rarr;1).  These explicit
annotations from DEC51 make sense of LCS48 section IV which mentions
A<sub>1</sub> without context and otherwise looks like a typo.
<blockquote>Acc. 15(2,1) transmit-clear to Acc. 6(8,7).  Acc. 6(8,7)
transmit-hold to Acc. 1(2,1). Then, Acc. 1(2,1) transmit-clear to Acc.
15(2,1)</blockquote>

<<Instructions: a1-based>>=
# Several instructions that use a1 as a temporary share the same sequence.
# Cycle 7: Save a1 in a13
# Transmit a1
p D-5 a1.6i
s a1.op6 A
s a1.cc6 C
s a1.rp6 1
p a1.6o C-4  # Trigger a15 to send in cycle 8
# D-5 -> B-10 triggers a13 receive
# Receive a13
p B-10 a13.3i
s a13.op3 γ
s a13.cc3 0
p D-5 a19.12i # Dummy to receive answer/restore a13
s a19.op12 0
s a19.cc12 0
s a19.rp12 3
p a19.12o T-7

# Cycle 8: C-4 sends a15; per-instruction work

# Cycle 9: per-instruction work

# Cycle 10: Receive answer
p T-7 a15.5i
s a15.op5 β
s a15.cc5 0
s a15.rp5 1
p a15.5o T-8

# Cycle 11: Restore a1 from a13
# T-8 -> B-11 is triggered by pulse amplifiers.
# Transmit a13
p B-11 a13.6i
s a13.op6 A
s a13.cc6 C
s a13.rp6 1
# Receive a1
p T-8 a1.3i
s a1.op3 β
s a1.cc3 0

# These are the steps that vary per instruction.
<<Instructions: 6(11,10,9)>>
<<Instructions: 6(8,7)>>
<<Instructions: M>>
@ %def B-10 B-11 T-7 T-8

<h4><a name="611109">6(11,10,9)</a></h4>

<pre>
  7. (a1:AC1, a13:γ01) # Save a1 [1]
  8. (a15:AC1), a6:γ01 # Add 15(11,2,1) into 6(11,10,9) [2,2*]
  9. a6:A01*, a1:γ01   # Get 6(11,10,9) in 1(11,2,1) (* from [[J-4]]) [5,5*]
 10. a1:AC1, (a15:β01) # Get 1(11,2,1) back in 15(11,2,1). [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: 6(11,10,9)>>=
# 6(11,10,9)
# Cycle 7: Dummy to delay V-2
p V-2 a2.6i
s a2.op6 0
s a2.cc6 0
s a2.rp6 1
p a2.6o T-1

# Cycle 8: Add a15(11,2,1) to a6(11,10,9)
p T-1 a6.7i
s a6.op7 γ
s a6.cc7 0
s a6.rp7 1
p a6.7o T-2

# Cycle 9: Receive 6(11,10,9) in 1(11,2,1)
# Fetch J-4 will send a6 this cycle.
p T-2 a1.7i
s a1.op7 γ
s a1.cc7 0
s a1.rp7 1
p a1.7o T-3

# Cycle 10: Transmit a1
# (a15 receive is part of common a1tmp sequence)
p T-3 a1.8i
s a1.op8 A
s a1.cc8 C
s a1.rp8 1
@ %def T-1 T-2 T-3

<h4><a name="687">6(8,7)</a></h4>

<pre>
  7. (a1:AC1, a13:γ01) # Save a1 [1]
  8. (a15:AC1), a6:δ01 # Add 15(2,1) into 6(8,7) [2,2*]
  9. a6:A01*, a1:δ01   # Get 6(8,7) in 1(2,1) (* from [[J-4]]) [5,5*]
 10. a1:AC1, (a15:β01) # Get 1(2,1) back in 15(2,1). [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: 6(8,7)>>=
# Cycle 7: Dummy to delay V-4
p V-4 a3.6i
s a3.op6 0
s a3.cc6 0
s a3.rp6 1
p a3.6o T-9

# Cycle 8: Add a15(2,1) to a6(8,7)
p T-9 a6.8i
s a6.op8 δ
s a6.cc8 0
s a6.rp8 1
p a6.8o T-10

# Cycle 9: Receive 6(8,7) in 1(2,1)
# Fetch J-4 will send a6 this cycle.
p T-10 a1.9i
s a1.op9 δ
s a1.cc9 0
s a1.rp9 1
p a1.9o T-11

# Cycle 10: Transmit a1
# (a15 receive is part of common a1tmp sequence)
p T-11 a1.10i
s a1.op10 A
s a1.cc10 C
s a1.rp10 1
@ %def T-9 T-10 T-11

<h4><a name=m>M</a></h4>

<p>Complement the number in A<sub>15</sub> in 7 cycles.  DU49 and DEC51 have
this as 8 cycles, and DEC51 implies it uses A<sub>1</sub> (1+13&rarr;1).  This
suggests a sequence like
<pre>
  7. (a1:AC1, a13:γ01) # Save a1. [1]
  8. (a15:AC1), a1:α01 # a1 get a15 to be complemented. [2]
  9. -                 # (to reuse 6(11,10,9), 6(8,7) sequence)
 10. a1:SC1, (a15:β01) # a1 send complement of a15. [1]
 11. (a13:AC1, a1:β01) # Restore a1. [1]
</pre>

<<Instructions: M>>=
# Cycle 7: Dummy to delay V-3
p V-3 a16.6i
s a16.op6 0
s a16.cc6 0
s a16.rp6 1
p a16.6o T-4

# Cycle 8: a1 gets a15
p T-4 a1.11i
s a1.op11 α
s a1.cc11 0
s a1.rp11 1
p T-4 a16.7i  # Dummy to wait for cycle 10.
s a16.op7 0
s a16.cc7 0
s a16.rp7 2
p a16.7o T-5

# Cycle 9: nop

# Cycle 10: Transmit a1 subtractively
# (a15 receive is part of common a1tmp sequence)
p T-5 a1.4i
s a1.op4 S
s a1.cc4 C
@ %def T-4 T-5

<p>This is roundabout if <code>a13.S</code> is free, since we could just say
<pre>
  7. a15:AC1, a13:β01  # Load a15. [2]
  8. a13:SC1, a15:β01  # Get complement back in a15. [1]
</pre>
<p>This and <code>NxD</code> suggest that by DEC51, <code>a13.S</code> was
crosswired to <a href="#trunks">digit trunk</a> 2 to save inputs on
temporaries.

<h4><a name="multiply">X</a></h4>

<p>LCS48 claims <code>X</code> takes 15 cycles, but the multiplier needs 14
cycles and fetch takes 7 cycles.  DU49 claims a more honest 20 cycles with its
6 cycle fetch.

<p>The static accumulator wiring given in LCS48 is different to the canonical
wiring in ETM, with different accumulator assignments.  Probably the physical
layout of the machine's units had changed slightly in its 1948 installation.

<pre>
  7. a12:0C1, m.1i       # Start multiplication immediately
  8. a15:AC1, (a12:α01)  # Multiplier triggers a12 to receive argument
  &vellip;
  21. (fetch)
</pre>

<<Instructions: multiply>>=
# Multiply
# The static multiplier wiring is set up for ier=a11 and icand=a12
p m.ier a11
p m.icand a12
p m.L a13
p m.R a15
s m.ieracc1 0
s m.iercl1 0
s m.icandacc1 α  # Trigger a12:α01 in cycle 8
s m.icandcl1 0
s m.sf1 off
s m.place1 10
s m.prod1 0

# Cycle 7: Start multiplication and clear icand
# Start multiplication
p E-5 m.1i
# Clear icand
p E-5 a12.6i
s a12.op6 0
s a12.cc6 C
s a12.rp6 1
p a12.6o M-1
# Trigger J-1 to transmit a15 to icand in cycle 8
p E-5 c.4i
p c.4o J-1  # NB uses trunk 1

# Cycle 8: Dummy program triggers a15:AC1

# Cycle 9..18: (multiply)

# Cycle 19: Add correction terms for signed arguments
# Correction from ier
p m.RS M-2
p M-2 a11.4i
s a11.op4 S
p M-2 a13.4i
s a13.op4 β
# Correction from icand
p m.DS M-3
p M-3 a12.3i
s a12.op3 S
# Pulse amplifiers trigger a15:β01 (M-3 -> B-3)

# Cycle 20: Combine partial products into a15
p m.F M-4
# Pulse amplifiers trigger a13:AC1 (M-4 -> B-11)
# Pulse amplifiers trigger a15:β01 (M-4 -> B-3)
p m.1o C-5  # Retrigger fetch sequence
@ %def M-1 M-2 M-3 M-4

<h4><a name="divsq">÷ and √</h4>

<<Instructions: divide/square root>>=
# Divider/square rooter accumulator wiring
p d.quotient a4
p d.numerator a5
p d.denominator a7
p d.shift a9

# A few sequences are common to divide and square root.
<<Instructions: divide/square root save>>
<<Instructions: divide/square root restore>>
<<Instructions: divide>>
<<Instructions: square root>>
@

<p>Two sub-sequences for saving and restoring A<sub>9</sub> can be reused for
these instructions to conserve programming resources.  These sequences require
three programs on A<sub>9</sub>, one on A<sub>5</sub>, and three pulse amps.

Reusing them requires four new dummy programs.

<<Instructions: divide/square root save>>=
# R-1: Transfer a15 to a5, then save a9 in a15.
# Cycle 0: Transfer a15 to a5.
# Pulse amplifiers trigger a15:AC1 (R-1 -> J-1)
p R-1 a5.7i
s a5.op7 α
s a5.cc7 0
s a5.rp7 1
p a5.7o R-2
# Cycle 1: Save a9 in a15.
p R-2 a9.6i
s a9.op6 A
s a9.cc6 C
s a9.rp6 1
# Pulse amplifiers trigger a15:β01 (R-2 -> B-3)
@ %def R-2

<<Instructions: divide/square root restore>>=
# R-3: Clear a9, then restore from a15.
# Cycle 0: Clear a9
p R-3 a9.7i
s a9.op7 0
s a9.cc7 C
s a9.rp7 1
p a9.7o R-4
# Cycle 1: Save a9 in a15.
# Pulse amplifiers trigger a15:AC1 (R-4 -> J-1)
p R-4 a9.8i
s a9.op6 γ
s a9.cc6 0
s a9.rp6 1
@ %def R-4

<h4><a name="div">÷</h4>

<p>A<sub>4</sub> (quotient) and A<sub>9</sub> (shifter) need to be saved in
A<sub>13</sub> and A<sub>15</sub>, respectively, since DEC51 has side-effect
(4+13&rarr;4).  

<pre>
  7. a5:0C1, a4:AC1, a13:γ01  # Save a4 in a13 [1]
  8. a15:AC1, a5:α01  # Transfer a15 to numerator [2]
  9. a9:AC1, a15:β01  # Save a9 in a15 [1]
 10. d.1i
 &vellip;
 90. a9:0C1
 91. a15:AC1, a9:γ01  # Restore a9 [2]
 92. a4:AC1, a15:β01  # Get quotient in a15 [1]
 93. a13:AC1, a4:β01  # Restore a4 [1]
</pre>

<<Instructions: divide>>=
# Use divider input 1, transmitting arguments via external programs not
# divider-generated pulses due to the need to shuffle accumulators.
s d.nr1 0
s d.nc1 0
s d.dr1 0
s d.dc1 0
s d.pl1 D10
s d.ro1 RO
s d.an1 1
s d.il1 NI

# Cycle 7: Clear a5 and save a4 in a13
p E-3 a5.6i
s a5.op6 0
s a5.cc6 C
s a5.rp6 1
p a5.6o R-1  # Trigger R-1 sequence for cycle 8+9
p E-3 a4.3i
s a4.op3 A
s a4.cc3 C
# Pulse amplifiers trigger a13:γ01 (E-3 -> B-10)
# Dummy to continue division
p E-3 i.Ci2
p i.Co2 V-10

# Cycle 8+9: Sequence R-1 (Q-1 -> R-1)

# Cycle 10-89*: Divide (* e.g.)
p Q-4 d.1i
p d.1o Q-5

# Cycle 90: Clear a9 before restoring
p Q-5 a9.7i
p a9.7o Q-6

# Cycle 91: Restore a9
p Q-6 a9.8i
p a9.8o Q-7

# Cycle 92: Transfer quotient to a15
p Q-7 a4.6i
p a4.6o Q-8

# Cycle 93: Restore a4
p Q-8 a4.6i
@ %def Q-1 Q-2 Q-3 Q-4 Q-5 Q-6 Q-7 Q-8 V-10

  8. a15:AC1, a5:α01  # Transfer a15 to numerator [2]
  9. a9:AC1, a15:β01  # Save a9 in a15 [1]
 10. d.1i
 &vellip;
 90. a9:0C1
 91. a15:AC1, a9:γ01  # Restore a9 [2]
 92. a4:AC1, a15:β01  # Get quotient in a15 [1]
 93. a13:AC1, a4:β01  # Restore a4 [1]

<h4><a name=sqrt>√</a></h4>

<p>For <code>√</code>, A<sub>7</sub> (2&times;root) and A<sub>9</sub> (shifter)
aren't mentioned as mutated, so save those in A<sub>13</sub> and
A<sub>15</sub>, respectively (7+13&rarr;7).

<p>The 5x reception requires a dedicated repeat program on A<sub>15</sub>
(can't reuse the normal receive program).

<pre>
  7. a5:0C1, a7:AC1, a13:γ01  # Save a7 in a13 [1]
  8. a15:AC1, a5:α01  # Transfer a15 to argument [2]
  9. a9:AC1, a15:β01  # Save a9 in a15 [1]
  &lt;Square root&gt;
 90. a9:0C1
 91. a15:AC1, a9:β01  # Restore a9 [2]
 92. a7:AC5, a15:β05  # Note repeat 5: get 10*root in a15 [1]
 97. a13:AC1, a7:β01  # Restore a7 [1]
</pre>

<<Instructions: square root>>=
s d.nr2 0
s d.nc2 0
s d.dr2 0
s d.dc2 0
s d.pl2 R10
s d.ro2 RO
s d.an2 4
s d.il2 NI
s d.da A
s d.ra A

p B-1 ...
@

<h4>DS</h4>

<p>Drop sign of A<sub>15</sub> in 7 cycles.  DEC51 implies this uses
A<sub>11</sub> (11+13&rarr;11).
<pre>
  7. a11:AC1, a13:γ01  # Save a11. [1]
  8. a15:AC1, a11:γ01  # Transmit a15, dropping sign. [2,2*]
  9. a11:AC1, a15:β01  # Get a15 without sign. [1]
 10. a13:AC1, a11:β01  # Restore a11. [1]
</pre>

<<Instructions: DS>>=
# DS
# Cycle 7: Save a11
p H-10 a11.9i
s a11.op9 A
s a11.cc9 C
s a11.rp9 1
p a11.9o x1
# Pulse amplifiers trigger a13:γ01 (H-10 -> B-10)
p H-10 

# Cycle 8: Transmit a15, dropping sign [trunk 2]
# Pulse amplifiers trigger a15:AC1 (x1 -> J-1)
p x1 a11.10i
s a11.op10 γ
s a11.cc10 0
s a11.rp10 1
p a11.10o x2
# Trigger B-3 a15:β01 next cycle.
p x1 c.5i
p c.5o B-3  # Uses trunk 1 this cycle

# Cycle 9: Get a15 without sign.
p x2 a11.11i
s a11.op11 A
s a11.cc11 C
s a11.rp11 1
p a11.11o x3
# Dummy from cycle 8 triggers a15:β01

# Cycle 10: Restore a11
p x3 a11.12i
s a11.op12 β
s a11.cc12 0
s a11.rp12 1
@

<p>There is a spare input on A<sub>15</sub>, so instead we could just say
<pre>
  0. a15:AC1, a13:β01  # Save a15 [2]
  1. a13:AC1, a15:ε01  # Receive a15 without sign [1,1*]
</pre>

<h4>NxD</h4>

<p>LCS48 claims 14/20/26 cycles for <code>N2D</code> / <code>N4D</code> /
<code>N6D</code>, i.e. 7 cycles plus 6 per pair of digits with on extra cycle
for <code>N2D</code>; DU49 and DEC51 pad this out by two cycles to 15/21/27
cycles with a 6 cycle fetch.  DEC51 implies using A<sub>18</sub> subtractively
(18-13&rarr;18), e.g.
<pre>
  a18:SC1, a13:β01  # Save -a18 (e.g. a18.A=1 and a18.S=2) [2]
  &vellip;
  a18:γ01           # Load and shift ft data [1]
  a18:AC1, a15:β01  # Add ft data into a15 [1]
  a13:SC1, a18:α01  # Restore -(a13-a18) = a18-a13 [2]
</pre>

<p>The LCS48 timing seem plausible even with DEC51's implied sequence.
<code>N(x+1)D</code> can do its thing and then reuse <code>NxD</code>
programming.  We can save cycles shuffling accumulators if we place the
necessary shifters on a single accumulator, so suppose A<sub>18</sub> has both
the @<< 4 input for <code>N6D</code> and the @<< 2 input for <code>N4D</code>.

<<Instructions: NxD>>=
# Cycle 7: (for all NxD instructions)
# Pulse amplifiers assert D-6 to fetch the operand.
# Save -a18 if triggered directly from decode.
p C-6 a18.2i
s a18.op2 S
s a18.cc2 C
#p C-6 a13.2i
#s a13.op2 β

<<Instructions: N6D>>
<<Instructions: N4D>>
<<Instructions: N2D>>
@

<h4>N6D</h4>

<pre>
    7. [[D-6]],          # Read operand
       a18:SC1, a13:β01  # Save -a18 [2]
    &vellip;
   12. [[G-8]], a18:δ01  # Receive @<< 4 shifted digits at a18. [1,1@<<4]
   13. [[D-2]],          # Trigger N4D sequence
       a18:AC1, a15:β01  # Add shifted digits to a15 [1]
    &vellip;
  (26. [[C-5]])
</pre>

<<Instructions: N6D>>=
# N6D cycle 7
# Await FT data
p V-7 a18.5i  # N6D
s a18.op5 0
s a18.cc5 0
s a18.rp5 5
p a18.5o .x1

# N6D cycle 12:
# Receive @<< 4 shifted digits from function table
p .x1 a18.6i
s a18.op6 δ
s a18.cc6 0
s a18.rp6 1
p a18.6o .x2
# Trigger N4D sequence via a dummy program
p .x1 a18.7i
s a18.op7 0
s a18.cc7 0
s a18.rp7 1
p a18.7o D-2

# N6D cycle 13:
# Add shifted digits to a15
p .x2 a18.7i
s a18.op7 A
s a18.cc7 C
s a18.rp7 1
p a18.7o .x3
p .x2 a15.2i
s a15.op2 β
s a15.cc2 0
@

<h4>N4D</h4>

<pre>
    7*. [[D-6]],         # Read operand
        a18:SC1, a13:β01 # Save -a18 (*unless N6D) [2]
    &vellip;
   12. [[G-8]], a18:γ01  # Receive @<< 2 shifted digits at a18 [1,1@<<2]
   13. [[D-1]],
       a18:AC1, a15:β01  # Add shifted digits into a15 [1]
   &vellip;
  (20. [[C-5]])
</pre>

<<Instructions: N4D>>=
# N4D cycle 7
# Await FT data
p D-2 a18.5i  # N4D'
s a18.op5 0
s a18.cc5 0
s a18.rp5 5
p a18.5o .x1
@

<h4>N2D</h4>

<p>To simplify programming the sequence, always save/restore A<sub>18</sub>
even though it's only needed for <code>N4D</code> and <code>N6D</code>.
[[C-5]] could plausibly be asserted earlier here.

<pre>
    7*. [[D-6]],         # Read operand
        a18:SC1, a13:β01 # Save -a18 (*unless N4D/N6D) [2]
    &vellip;
   12. [[G-8]], a15:β01  # Add digits into a15 [1]
   13. a13:SC1, a18:α01  # Restore -(a13-a18) = a18-a13 [2]
   14. [[C-5]]           # Trigger next fetch
</pre>

<<Instructions: N2D>>=
# N2D cycle 7
# Await FT data
p D-1 a18.5i  # N2D'
s a18.op5 0
s a18.cc5 0
s a18.rp5 5
p a18.5o .x1
@

<h4>6Rx/C.T.</h4>

<p><code>6R3</code> and <code>6R6</code> are 13 cycles, and <code>C.T.</code>
is 14 for taken and 8 for not-taken branches.  The cycle counts should be
reliable, because the next fetch is dependent.  LCS48 does not specify what
happens to the unused digits of A<sub>15</sub> for <code>6Rx</code>, but DU49
specifies that they're cleared, so let's go with that.

<h4>6R3</h4>

<p>DEC51 implies this uses A<sub>10</sub> (10-13&rarr;10).

<pre>
  NB need to reset order selector ring
  7. a10:SC1, a13:β01  # Save -a10 [2]
  8. a6:AC1, a10:β01   # Add a6(11-4) [5,5(11-4)]
  9. a15:AC1, a10:γ01  # Add a15(3-1) [2,2(3-1)]
 10. a10:AC1, a6:β01   # Set new PC [1]
 11. a13:SC1, a10:α01  # Restore -a10 [2]
 12. (fetch)
</pre>

<h4>6R6</h4>

<p>DU49 also has this instruction, but DEC51 doesn't.  It does have a similar
instruction, <code>6<sub>3</sub></code> which saves 15(3,2,1) into 6(6,5,4)
without clobbering the PC; that uses A<sub>20</sub> (20-13&rarr;20).

<pre>
  NB need to reset order selector ring
  7. a20:SC1, a13:β01  # Save -a20 [2]
  8. a6:AC1, a20:γ01   # Add a6(11-7) [5,5(11-7)]
  9. a15:AC1, a20:δ01  # Add a15(6-1) [2,2(6-1)]
 10. a20:AC1, a6:β01   # Set new PC [1]
 11. a13:SC1, a20:α01  # Restore -a20 [2]
 12. (fetch)
</pre>

<h4>C.T.</h4>

<p>LCS48 sneakily mentions yet another new stepper (&ldquo;P-M discriminator
no. 2&rdquo;) in the text above Section IV.  Without this, we'd need a separate
dedicated accumulator for magnitude discrimination.  It's curious that
<code>C.T.</code>-taken is 14 cycles, since 13 cycles seems possible.  DU49
also has this extra cycle.  DEC51 and LCS48 both explicitly state they use
A<sub>10</sub> (10-13&rarr;10).

<pre>
  7. a15:AC1, discriminate P-M
  M8. (dependent fetch)    P8. a10:SC1, a13:β01  # Save -a10 [2]
                           P9. a6:AC1, a10:β01   # a6(11-7,000,6-4). [5,5*]
                          P10. a10:AC1, a6:β01   # Set PC [1]
                          P11. a13:SC1, a10:α01  # Restore -a10 [2]
                          P12. (fetch)
</pre>

<h4>18↔20</h4>

<p>Uncharacteristically, LCS48 lists <code>18↔20</code> as 9 cycles, even
though it can be hidden behind an overlapping fetch.  Perhaps it's avoiding an
overlapping dummy program on A<sub>20</sub> in the fetch sequence.
<code>18↔20</code> is gone from DU49 and DEC51.  The annotation in LCS48
Section IV suggests A<sub>15</sub> must be 0 so assume it's used for the
exchange.

<pre>
  7. a20:AC1, a15:β01  # a15=a20 [1]
  8. a18:AC1, a20:β01  # a20=a18 [1]
  9. a15:AC1, a18:α01  # a18=a15 [2]
</pre>

<h4><a name=ft>F.T.</a></h4>

<p><code>F.T.</code> fetches data from any function table in 13 cycles by
reusing fetch machinery without triggering decode.  But function table input #1
is set up to send [[J-4]] which would trigger PC increment and advance the
order selector ring, which is problematic because <code>F.T.</code> has no
operand.

<p>The ballistics program in LCS48 has <code>N4D 04 86 8l F.T.</code>
which&mdash;apart from the fact that FT2's constant data has address 90 in that
listing&mdash;suggests that we're supposed to code 3-5 instead of 0-2 for
function table 1/2/3 for <code>F.T.</code>  DU49 corroborates this encoding and
clarifies that instruction lookups use A-2 and data lookups use A+2 to permit
using lines -2 through 101 of each table.  Thus <code>N4D 04 86 8l F.T.</code>
would index line 88 of table 2, which in the A-2 instruction address space is
(confusingly) line 90.

<p>If you wrote <code>N4D 01 00 8l F.T.</code> by mistake, it might either hang
or store an instruction line and skip one order, depending on the wiring.  The
world may never know.

<<Instructions: F.T.>>=
<<Instructions: F.T. cycle 7>>
<<Instructions: F.T. cycle 8>>
@

<<Instructions: F.T. cycle 7>>=
# F.T. order uses E-8=3,4,5 for G-9, G-10, G-11.
p sft.4o G-9
p sft.5o G-10
p sft.6o G-11
@ %def G-9 G-10 G-11

<<Instructions: F.T. cycle 8>>=
# Read function table for F.T., using C to trigger sending the argument.
# Note this uses A+2 addressing.
p G-9 f1.2i
s f1.op2 A+2
s f1.cl2 C
s f1.rp2 1
p f1.C N-10

p G-10 f2.2i
s f2.op2 A+2
s f2.cl2 C
s f2.rp2 1
p f2.C N-10

p G-11 f3.2i
s f3.op2 A+2
s f3.cl2 0
s f3.rp2 1
p f3.C N-10

# Look up signs from the tables, too.
s f1.mpm1 T
s f1.mpm2 T
s f2.mpm1 T
s f2.mpm2 T
s f3.mpm1 T
s f3.mpm2 T
@ %def N-10

<h4>Pr.</h4>
<<Instructions: Pr.>>=
# Printer
# TODO Add some way to specify printer wiring to the simulator.  This
# instruction set expects to print a1, a2, and a15-20.
p O-1 i.Pi  # Pr.
p i.Po C-5  # fetch+decode
s pr.1 P    # a1
s pr.2 P    # a1
s pr.3 P    # a2
s pr.4 P    # a2
s pr.5 P    # a15
s pr.6 P    # a15
s pr.7 P    # a16
s pr.8 P    # a16
s pr.9 P    # a17
s pr.10 P   # a17
s pr.11 P   # a18
s pr.12 P   # a18
s pr.13 P   # a19
s pr.14 P   # a19
s pr.15 P   # a20
s pr.16 P   # a20
@

<h4>Rd.</h4>
<<Instructions: Rd.>>=
# Reader
p O-2 i.Ri  # Rd.
p i.Ro C-5  # fetch+decode
@

<h4><a name=shifts>Sh and Sh'</a></h4>

<h5>What do they actually do</h5>

<p>The vaguest instructions in LCS48 are the shifts, <code>Sh jk</code> and
<code>Sh' jk</code>.  DU49 and DEC51 use a different encoding, but we can
probably assume the same semantics&mdash;they at least clarify that the shifts
are supposed to be arithmetic.  <code>Sh</code> operates on A<sub>15</sub>
alone, and <code>Sh'</code> also operates on A<sub>12</sub> to shift
A<sub>15</sub>=Sabcdefghij as described in this diagram:

<pre>
  Shift(')    jk     New a12(')   New a15
 Sabcdefghij  01 -> S?????????a  Sbcdefghij0      S = sign digit
              02 -> S????????ab  Scdefghij00      ? = 0 would make sense, but
              03 -> S???????abc  Sdefghij000          not specified.
              04 -> S??????abcd  Sefghij0000
              05 -> S?????abcde  Sfghij00000
              91 -> Sj000000000  SSabcdefghi
              92 -> Sij00000000  SSSabcdefgh
              93 -> Shij0000000  SSSSabcdefg
              94 -> Sghij000000  SSSSSabcdef
              95 -> Sfghij00000  SSSSSSabcde
</pre>

<p>All the references are unclear about sign extension into A<sub>12</sub> for
<code>Sh' 0x</code>.  The example programs in LCS48 don't help much; in the
ballistics problem, <code>Sh'</code> is used exclusively with negative
arguments to put immediate values at the top of A<sub>12</sub>, e.g. <code>N2D
01 Sh' 92</code>&mdash;how RISCy!  The self-test program in LCS48 Table 5.I
shifts a test input left by n and adds A<sub>12</sub> to A<sub>15</sub>
(effectively rotating left by n), then rotates back right by n and subtracts
the result from an expected value.
<pre>
  10t     ; Get test input in 15
  Sh' 01  ; Shift left 1 (abcdefghij)
  12t     ; ?????????a + bcdefghij0 = bcdefghija?
  Sh' 91  ; Shift right 1 (bcdefghija)
  12t     ; a000000000 + Sbcdefghij? = abcdefghij?
  M       ; Complement answer
  14t     ; Subtract from expected output 1
  1l      ; Test result in 1
</pre>

<p>LCS48 says only that this takes 20 cycles and uses A<sub>13</sub>.  Just
fetching <code>jk</code> takes 12 cycles, so decoding <code>jk</code> and doing
the work must fit in 8 cycles.  DU49 uses its extra code space to avoid
requiring an operand and claims an impressive 9 cycles, i.e. fetch + 3 cycles.
DEC51 says 12 cycles i.e. fetch + 6 cycles and implies using A<sub>14</sub>
(14-13&rarr;14).  6/8 cycles vs 3 cycles of work might mean two different
datapaths&mdash;3 cycles suggests a bunch of shift adapters, while 6/8 cycles
(with just a single temporary called out for side-effects) implies incremental
shifting.

<h5>A bunch of adapters</h5>
<p>An easy datapath would just use twenty shift adapters.  For instance say
<tt>aK.δ</tt> shifts @<< k and <tt>aK.ε</tt> shifts @>> (10-k).
<pre>
 12-13. (decode jk)
 14. aK:AC1, a13:γ01, (a12:0C1)' # Save aK in a13 [1]
 15. a15:A01, aK:δ01, (a12:α01)' # Shift a15 in aK ('save in a12) [2,2*]
 16. aK:AC1, a15:β01             # Store new a15 [1]
 17. (a12:AC1)', aK:ε01          # Shift old a15 again in aK [1,1*]
 18. aK:AC1, (a12:β01)'          # Store new a12 [1]
 19. a13:AC1, aK:β01             # Restore aK from a13 [1]
 20. (fetch)
</pre>
<p>Steps marked with <tt>'</tt> are done only for <code>Sh'</code>.  This
requires three inputs each on ten accumulators, one input on trunk 1 and 2
inputs per shift.  Those fit all right.

<p>The challenge with this approach is programming it.  <code>Sh'</code> can
nicely reuse the same sequences as <code>Sh</code> with an orthogonal four
program sequence on A<sub>12</sub>.  But each of ten <tt>jk</tt>s needs a
separate six cycle sequence, consuming 60 of 160 available repeat programs and
up to 60 pulse amplifier channels, assuming no magic new hardware.  This is
probably too expensive.

<h5>Incremental shifting, slowly</h5>

<p>An incremental datapath uses the same accumulators for all shift amounts, so
there could be one shift sequence per direction, <tt>j</tt>.  <tt>k</tt> might
trigger e.g. step <tt>14+2(k-1)</tt> of the sequence,
<pre>
  12-13. (decode jk)
  # Initially a13=x, a14=0.
  14. a13:AC1, a14:δ01  # Shift x by one digit
  15. a14:AC1, a13:γ01  # Get x back in a13
  16. a13:AC1, a14:δ01  # Shift x by one digit
  17. a14:AC1, a13:γ01  # Get x back in a13
  &vellip;
  13+2(k-1). a13:AC1, a14:δ01
  14+2(k-1)+1. a14:AC1, a13:γ01
  &vellip;
</pre>
<p>But this would have variable timing which no reference mentions.  Instead,
to decouple <tt>j</tt> and <tt>k</tt> decode, <tt>j</tt> might control which
receive program is active for 5 rounds and <tt>k</tt> might trigger 1-5
transmit steps.
<pre>
  o-o-o-o-o -> a14:δ01/a13:γ01
  j=9
  o-o-o-o-o -> a14:ε01/a13:γ01
  j=0
  o-o-o-o-o -> a13:AC1/a14:AC1
  5 4 3 2 1 = k
  (Each dummy program here has rp2)
</pre>
<p><code>Sh'</code> requires an extra two steps per round.
<pre>
  12. (decode jk)
  # Initially a12'=0, a13=x, a14=0, a15=tmp.
  13. (a12:AC1)', a14:ε01   # residual @<<= 1 to make room for new digit
  14. a14:AC1, (a12:γ01)'   # Get residual back in a12
  15. a13:AC1, a14:δ01, (a12:δ01)' # Shift in/out new digit
  16. a14:AC1, a13:γ01
   &vellip;
</pre>
<p><code>Sh'</code> control can be accomplished as one more parallel sequence
on A<sub>12</sub> per round.  This would come out to 13 cycles fetch/decode +
20 cycles for shifting + 2-3 for temporary shuffling, with around 20-30 repeat
programs.  This seems way too slow.

<h5>Incremental shifting, ping-ponging</h5>

<p>A faster way to shift A<sub>13</sub> by +5 incrementally is to ping-pong
between accumulators which each have a shift input, e.g.
<pre>
 # Initially a13=x, a14=0.
 13. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<1)
 14. a14:AC1, a13:δ01  # Shift +1 (-> a13=x@<<2, a14=0) 
 15. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<3)
 16. a14:AC1, a13:δ01  # Shift +1 (-> a13=x@<<4, a14=0) 
 17. a13:AC1, a14:δ01  # Shift +1 (-> a13=0, a14=x@<<5)
</pre>
<p>Because the transmitting accumulator alternates, even/odd shifts leave the
answer in different places.  Collecting the answer based on <tt>k (mod 2)</tt>
after shifting concludes requires separately timed dummy programs.
<pre>
  o-o-o-o-o   a14:δ01/a13:δ01
  j=9
  o-o-o-o-o   a14:ε01/a13:ε01
  j=0
  o-o-o-o-o-x a13:AC1/a14:AC1
    o-------o (swap a13/a14)
        o---'
  5 4 3 2 1 = k
</pre>

<p><code>Sh'</code> is harder.  We could cycle between the three available
accumulators if they had both ±1 and ±9 adapters, but there aren't enough free
inputs on either A<sub>13</sub> or A<sub>15</sub>.  Pre-shifting by ±5 would
let us incrementally shift the rest of the way to A<sub>12</sub> using ±1
shifters, e.g.
<pre>
 # (Pre-shift x±5 so that a sequence of ±1 shifts can compute the residual.)
 12. (decode jk)
 # Initially e.g. a12=r, a13=x, a14=0
 13. a12:AC1, a14:ε01          # -> a12=0 a13=x a14=r
 14. a13:AC1, a12:δ01, a14:δ01 # -> a12=x a13=0 a14=r
 15. a14:AC1, a13:ε01          # -> a12=x a13=r a14=0
 16. a12:AC1, a13:δ01, a14:δ01 # -> a12=0 a13=r a14=x
 17. a13:AC1, a12:ε01          # -> a12=r a13=0 a14=x
 18. a14:AC1, a12:δ01, a13:δ01 # -> a12=r a13=x a14=0
 19. a12:AC1, a14:ε01          # -> a12=0 a13=x a14=r
 20. a13:AC1, a12:δ01, a14:δ01 # -> a12=x a13=0 a14=r
 21. a14:AC1, a13:ε01          # -> a12=x a13=r a14=0
 22. a12:AC1, a13:δ01, a14:δ01 # -> a12=0 a13=r a14=x
</pre>
<p>However, this would need to be a separate sequence since <code>Sh</code>
doesn't reserve A<sub>12</sub>, and that seems too clunky.

<h5>Incremental shifting, weighted shifts</h5>

<p>A cleverer approach would be to use an optional ±2/±4 shift on
A<sub>14</sub> followed by a ±1 shift on A<sub>13</sub>.  Computing
A<sub>12</sub> for <code>Sh'</code> would use another ±2/±4, ±1 shift sequence
followed by ±5 which should probably be done last, on A<sub>12</sub>.

<table>
<tr><th>shift<th>residual<th>answer<th style="border-left: 4px solid #ccc">shift<th>residual<th>answer
<tr><td>+1<td>-4-5<td>+1    <td style="border-left: 4px solid #ccc">-1<td>+4+5<td>-1
<tr><td>+2<td>-2-1-5<td>+2  <td style="border-left: 4px solid #ccc">-2<td>+2+1+5<td>-2
<tr><td>+3<td>-2-5<td>+2+1  <td style="border-left: 4px solid #ccc">-3<td>+2+5<td>-2-1
<tr><td>+4<td>-1-5<td>+4    <td style="border-left: 4px solid #ccc">-4<td>+1+5<td>-4
<tr><td>+5<td>-5<td>+4+1    <td style="border-left: 4px solid #ccc">-5<td>+5<td>-4-1
</table>
<pre>
   7. a14:SC1, a13:β01, (a12:0C1)' # Save -a14 [2]
   &vellip;
  12-13. (decode jk)
  14. a15:AC1, a14:[αβγδε]01,  # Shift answer 0/±2/±4,
      (a12:[αβγδε]01)'         # and residual 0/±2/±4 [2]
  15. a13:AC1, a15:β01         # Shuffle temp to a15 [1]
  16. a14:AC1, a13:[γδε]01     # Shift answer 0/±1 [1]
  17. a15:AC1, a14:α01         # Restore -a14 [2]
  18. a13:AC1, a15:β01         # Answer to a15 [1]

  19. a12:AC1, a13:[γδε]01     # Shift residual 0/±1 [1]
  20. a13:AC1, a12:


  16. a12:AC1, a13:[γδε]01
  17. a13:AC1, a12:

  15. a13:AC1, a15:β01         # Move saved -a14 to a15
  16. a14:AC1, a13:[γδε]01     # Shift answer   17. 

  14. a13:AC1,    a14:[βγδε]01 # Shift answer ±4/±2 [2]
  15. a14:AC1,    a13:[γδε]01  # Shift answer 0/±1 [1]
  16. a15:AC1,    a14:α01      # Restore a14
  17. a13:AC1,    a15:β01      # Save answer
  18. (a12:AC1)', a13:[γδε]01  # Shift residual 0/±1 [1]
  19. (a13:AC1)', a12:[βγδε]01 # Shift residual ±4/±2 [1]
  20. (fetch)
</pre>

<p>The control is expensive.  Direction and shift amount are not orthogonal,
and it isn't entirely clear that <code>Sh'</code> can be either.  With the
crunch for temporaries, it's slower than the clunky

<h4>Decoding jk</h4>
<p>LCS48 says nothing about decoding jk, and it was gone by DU49. Section II
says that &ldquo;by the addition of four small units, it became possible to
speed the process up considerably and have 60 orders&rdquo;, then goes on to
mention
<ol>
<li>Ten-stage stepper
<li>Order selector
<li>Function table selector
</ol>
<p>So something is certainly missing here.  (P-M discriminators aren't
mentioned until Section III, and then only in passing, so probably aren't one
of the &ldquo;four small units&rdquo; added for decode).

<p>The least inventive solution is to throw more hardware at the problem, e.g.
a P-M discriminator (j) wired to two additional six-stage steppers (k)
analogous to the FT selector.  Wilder possibilities abound... the complement of
k=1-5 could drive a counter whose sign says to shift one step, we could somehow
reuse instruction decode with an additional layer of output gating, etc.

<h4>Implementation</h4>
<p>Lacking any evidence about plans for decode hardware, this implementation
uses some additional steppers that control a bunch of shifters.  The control
for an incremental datapath is too elaborate.

<h2><a name=prog>Program line assignments</a></h2>

<p>This is an index of program line assignments at a glance.  Blue shaded cells
represent assignments specified in LCS48, pink cells are from RIF, and
non-shaded cells are specific to this implementation.  <tt>noweb</tt> also
generates a separate, cross-referenced textual <a href="#index">index</a>.

<table class="dense" style="text-align: center; padding: 2px;">
<tr><td><th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<th>11
<tr style="vertical-align: top"><td style="font-weight: bold">A-
<td>[[A-1]]<br>init
<td>[[A-2]]<br>
<td>[[A-3]]<br>os.cdi
<td>[[A-4]]<br>
<td>[[A-5]]<br>
<td>[[A-6]]<br>
<td>[[A-7]]<br>
<td>[[A-8]]<br>
<td>[[A-9]]<br>
<td>[[A-10]]<br>
<td>[[A-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">B-
<td class=given>[[B-1]]<br>√
<td class=given2>[[B-2]]<br>i0x
<td class=given>[[B-3]]<br>a15recv
<td class=given>[[B-4]]<br>a1tmp'
<td class=given2>[[B-5]]<br>i1x
<td>[[B-6]]<br>
<td>[[B-7]]<br>
<td>[[B-8]]<br>
<td>[[B-9]]<br>
<td>[[B-10]]<br>a13recv
<td>[[B-11]]<br>a13send
<tr style="vertical-align: top"><td style="font-weight: bold">C-
<td class=given>[[C-1]]<br>xl
<td class=given>[[C-2]]<br>8t
<td class=given>[[C-3]]<br>18↔20
<td class=given>[[C-4]]<br>a1tmp+8
<td class=given>[[C-5]]<br>decode
<td class=given>[[C-6]]<br>a18tmp
<td class=given>[[C-7]]<br>13l
<td class=given>[[C-8]]<br>20l
<td class=given>[[C-9]]<br>16t
<td class=given>[[C-10]]<br>Sh'
<td class=given>[[C-11]]<br>Sh
<tr style="vertical-align: top"><td style="font-weight: bold">D-
<td>[[D-1]]<br>
<td>[[D-2]]<br>
<td class=given>[[D-3]]<br>xt
<td class=given>[[D-4]]<br>uv
<td class=given>[[D-5]]<br>a1tmp
<td class=given>[[D-6]]<br>fetch
<td class=given>[[D-7]]<br>AB
<td class=given>[[D-8]]<br>CD
<td class=given>[[D-9]]<br>EF
<td class=given>[[D-10]]<br>GH
<td class=given>[[D-11]]<br>JK
<tr style="vertical-align: top"><td style="font-weight: bold">E-
<td class=given>[[E-1]]<br>ftrd
<td class=given2>[[E-2]]<br>2[1]
<td class=given>[[E-3]]<br>÷
<td class=given>[[E-4]]<br>6l
<td class=given>[[E-5]]<br>X
<td class=given>[[E-6]]<br>6R3
<td class=given>[[E-7]]<br>6R6
<td class=given>[[E-8]]<br>5[3]
<td class=given>[[E-9]]<br>sft.cdi
<td class=given>[[E-10]]<br>os.i
<td class=given>[[E-11]]<br>sft.1o
<tr style="vertical-align: top"><td style="font-weight: bold">F-
<td class=given>[[F-1]]<br>sft.2o
<td class=given>[[F-2]]<br>sft.3o
<td class=given>[[F-3]]<br>os.Ri
<td class=given>[[F-4]]<br>PC inc
<td class=given>[[F-5]]<br>p.cdi
<td class=given2>[[F-6]]<br>2[2]
<td class=given2>[[F-7]]<br>pm1.i
<td class=given2>[[F-8]]<br>pm1.9
<td class=given2>[[F-9]]<br>pm1.0
<td>[[F-10]]<br>
<td>[[F-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">G-
<td>[[G-1]]<br>
<td class=given>[[G-2]]<br>C.T.
<td class=given2>[[G-3]]<br>pm2.di
<td class=given2>[[G-4]]<br>pm2.i
<td class=given2>[[G-5]]<br>pm2.0
<td class=given2>[[G-6]]<br>os.cdi
<td class=given2>[[G-7]]<br>pm1.cdi
<td class=given>[[G-8]]<br>os.i
<td>[[G-9]]<br>sft.4o
<td>[[G-10]]<br>sft.5o
<td>[[G-11]]<br>sft.6o
<tr style="vertical-align: top"><td style="font-weight: bold">H-
<td class=given>[[H-1]]<br>14l
<td class=given>[[H-2]]<br>16l
<td class=given>[[H-3]]<br>17l
<td class=given>[[H-4]]<br>18l
<td class=given>[[H-5]]<br>19l
<td class=given>[[H-6]]<br>17t
<td class=given>[[H-7]]<br>18t
<td class=given>[[H-8]]<br>19t
<td class=given>[[H-9]]<br>20t
<td class=given>[[H-10]]<br>DS
<td class=given>[[H-11]]<br>F.T.
<tr style="vertical-align: top"><td style="font-weight: bold">J-
<td class=given>[[J-1]]<br>a15send
<td class=given>[[J-2]]<br>pcseq
<td class=given>[[J-3]]<br>uv'
<td class=given>[[J-4]]<br>ft.NC
<td>[[J-5]]<br>
<td>[[J-6]]<br>
<td>[[J-7]]<br>
<td>[[J-8]]<br>
<td>[[J-9]]<br>
<td>[[J-10]]<br>
<td>[[J-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">K-
<td>[[K-1]]<br>
<td>[[K-2]]<br>
<td>[[K-3]]<br>
<td>[[K-4]]<br>
<td>[[K-5]]<br>
<td>[[K-6]]<br>
<td>[[K-7]]<br>
<td>[[K-8]]<br>
<td>[[K-9]]<br>
<td>[[K-10]]<br>
<td>[[K-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">L-
<td class=given>[[L-1]]<br>9t
<td class=given>[[L-2]]<br>10t
<td class=given>[[L-3]]<br>11t
<td class=given>[[L-4]]<br>12t
<td class=given>[[L-5]]<br>13t
<td class=given>[[L-6]]<br>14t
<td class=given>[[L-7]]<br>8l
<td class=given>[[L-8]]<br>9l
<td class=given>[[L-9]]<br>10l
<td class=given>[[L-10]]<br>11l
<td class=given>[[L-11]]<br>12l
<tr style="vertical-align: top"><td style="font-weight: bold">M-
<td>[[M-1]]<br>X+8
<td>[[M-2]]<br>Xrs
<td>[[M-3]]<br>Xds
<td>[[M-4]]<br>Xf
<td>[[M-5]]<br>
<td>[[M-6]]<br>
<td>[[M-7]]<br>
<td>[[M-8]]<br>
<td>[[M-9]]<br>
<td>[[M-10]]<br>
<td>[[M-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">N-
<td>[[N-1]]<br>
<td>[[N-2]]<br>
<td>[[N-3]]<br>
<td>[[N-4]]<br>
<td>[[N-5]]<br>
<td>[[N-6]]<br>
<td>[[N-7]]<br>
<td>[[N-8]]<br>
<td>[[N-9]]<br>
<td>[[N-10]]<br>ft.C
<td>[[N-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">O-
<td class=given>[[O-1]]<br>Pr.
<td class=given>[[O-2]]<br>Rd.
<td>[[O-3]]<br>
<td>[[O-4]]<br>
<td>[[O-5]]<br>
<td>[[O-6]]<br>
<td>[[O-7]]<br>
<td class=given>[[O-8]]<br>a1recv
<td>[[O-9]]<br>
<td>[[O-10]]<br>
<td>[[O-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">P-
<td>[[P-1]]<br>
<td>[[P-2]]<br>
<td>[[P-3]]<br>
<td>[[P-4]]<br>
<td>[[P-5]]<br>
<td>[[P-6]]<br>
<td>[[P-7]]<br>
<td>[[P-8]]<br>
<td>[[P-9]]<br>
<td>[[P-10]]<br>
<td>[[P-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">Q-
<td>[[Q-1]]<br>÷+8
<td>[[Q-2]]<br>
<td>[[Q-3]]<br>
<td>[[Q-4]]<br>
<td>[[Q-5]]<br>
<td>[[Q-6]]<br>
<td>[[Q-7]]<br>
<td>[[Q-8]]<br>
<td>[[Q-9]]<br>
<td>[[Q-10]]<br>
<td>[[Q-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">R-
<td>[[R-1]]<br>
<td>[[R-2]]<br>
<td>[[R-3]]<br>
<td>[[R-4]]<br>
<td>[[R-5]]<br>
<td>[[R-6]]<br>
<td>[[R-7]]<br>
<td>[[R-8]]<br>
<td>[[R-9]]<br>
<td>[[R-10]]<br>
<td>[[R-11]]<br>
<tr style="vertical-align: top"><td style="font-weight: bold">S-
<td class=given>[[S-1]]<br>1l
<td class=given>[[S-2]]<br>2l
<td class=given>[[S-3]]<br>3l
<td class=given>[[S-4]]<br>4l
<td class=given>[[S-5]]<br>5l
<td class=given>[[S-6]]<br>7l
<td class=given>[[S-7]]<br>2t
<td class=given>[[S-8]]<br>3t
<td class=given>[[S-9]]<br>4t
<td class=given>[[S-10]]<br>5t
<td class=given>[[S-11]]<br>7t
<tr style="vertical-align: top"><td style="font-weight: bold">T-
<td>[[T-1]]<br>611+8
<td>[[T-2]]<br>611+9
<td>[[T-3]]<br>611+10
<td>[[T-4]]<br>M+8
<td>[[T-5]]<br>M+10
<td class=given>[[T-6]]<br>uv+8
<td>[[T-7]]<br>a1tmp+10
<td>[[T-8]]<br>a1tmp+11
<td>[[T-9]]<br>68+8
<td>[[T-10]]<br>68+9
<td>[[T-11]]<br>68+10
<tr style="vertical-align: top"><td style="font-weight: bold">V-
<td class=given>[[V-1]]<br>6t
<td class=given>[[V-2]]<br><span style="font-size:80%">6(11,10,9)</span>
<td class=given>[[V-3]]<br>M
<td class=given>[[V-4]]<br>6(8,7)
<td class=given>[[V-5]]<br>N2D
<td class=given>[[V-6]]<br>N4D
<td class=given>[[V-7]]<br>N6D
<td class=given>[[V-8]]<br>N3D8
<td class=given>[[V-9]]<br>1t
<td class=given2>[[V-10]]<br>div+8
<td>[[V-11]]<br>
</table>

<h2><a name=index>Index</a></h2>
<h3>Chunks</h3>
<nowebchunks>
<h3>Identifiers</h3>
<nowebindex>

</body>
</html>
