// +build ignore
// Generates permuters.go, run with go generate
package main

import (
	"fmt"
	"log"
	"os"
	"strings"
)

var orders [][11]int = [][11]int{
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 0},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0},
	[11]int{0, 0, 0, 0, 0, 0, 0, 0, 9, 10, 0},
	[11]int{0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 11},
	[11]int{0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 0},
	[11]int{0, 0, 0, 0, 0, 6, 7, 8, 9, 10, 11},
	[11]int{0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0},
	[11]int{0, 0, 0, 0, 5, 6, 3, 4, 1, 2, 0},
	[11]int{0, 0, 0, 0, 5, 6, 7, 8, 0, 0, 0},
	[11]int{0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0},
	[11]int{0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11},
	[11]int{0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0},
	[11]int{1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 11},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 10, 9, 11},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 11, 11, 0},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11},
	[11]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0},
	[11]int{1, 2, 3, 4, 5, 6, 9, 10, 7, 8, 0},
	[11]int{1, 2, 3, 4, 5, 6, 9, 10, 7, 8, 11},
	[11]int{1, 2, 3, 4, 9, 10, 7, 8, 5, 6, 0},
	[11]int{1, 2, 3, 4, 9, 10, 7, 8, 5, 6, 11},
	[11]int{1, 2, 9, 10, 5, 6, 7, 8, 3, 4, 0},
	[11]int{1, 2, 9, 10, 5, 6, 7, 8, 3, 4, 11},
	[11]int{10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	[11]int{3, 4, 1, 2, 0, 0, 0, 0, 0, 0, 0},
	[11]int{3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 11},
	[11]int{5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0},
	[11]int{7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	[11]int{9, 0, 0, 0, 0, 0, 0, 0, 0, 11, 10},
	[11]int{9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	[11]int{9, 10, 3, 4, 5, 6, 7, 8, 1, 2, 0},
	[11]int{9, 10, 3, 4, 5, 6, 7, 8, 1, 2, 11},
}

func writePermuteFunction(f *os.File, id int, order [11]int) {
	shifts := [11 + 11]int{}
	for j, pos := range order {
		if !(pos >= 0 && pos <= 11) {
			fmt.Fprintf(os.Stderr, "invalid digit field in permutation")
		}
		if pos != 0 {
			amount := (pos - 1) - j
			shifts[amount+11] |= 1 << j
		}
	}
	fmt.Fprintf(f, "// %v\n", order)
	fmt.Fprintf(f, "//go:nosplit\n")
	fmt.Fprintf(f, "func permute%d(j *Jack, val int) {\n", id)
	fmt.Fprintf(f, "\tif !j.OtherSide.Disabled {\n")
	terms := []string{}
	for i, digits := range shifts {
		amount := i - 11
		if digits != 0 {
			term := ""
			if amount > 0 {
				term = fmt.Sprintf("((val >> %d) & %#x)", amount, digits)
			} else if amount == 0 {
				term = fmt.Sprintf("(val & %#x)", digits)
			} else if amount < 0 {
				term = fmt.Sprintf("((val << %d) & %#x)", -amount, digits)
			}
			terms = append(terms, term)
		}
	}
	fmt.Fprintf(f, "\t\tval = %s\n", strings.Join(terms, " |\n\t\t"))
	fmt.Fprintf(f, "\t\tif val != 0 {\n")
	fmt.Fprintf(f, "\t\t\tif j.OtherSide.OnReceive != nil {\n")
	fmt.Fprintf(f, "\t\t\t\tj.OtherSide.OnReceive(j.OtherSide, val)\n")
	fmt.Fprintf(f, "\t\t\t} else {\n")
	fmt.Fprintf(f, "\t\t\t\tj.OtherSide.Transmit(val)\n")
	fmt.Fprintf(f, "\t\t\t}\n")
	fmt.Fprintf(f, "\t\t}\n")
	fmt.Fprintf(f, "\t}\n")
	fmt.Fprintf(f, "}\n\n")
}

func main() {
	f, err := os.Create("permuters.go")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	fmt.Fprintln(f, "// Generated by gen_permuters.go")
	fmt.Fprintln(f, "package main\n")
	fmt.Fprintf(f, "import (\n")
	fmt.Fprintf(f, "\t. \"github.com/jeredw/eniacsim/lib\"\n")
	fmt.Fprintf(f, ")\n\n")
	for i, order := range orders {
		writePermuteFunction(f, i, order)
	}
	fmt.Fprintf(f, "func getCustomPermuter(order [11]int) (JackHandler, bool) {\n")
	for i, order := range orders {
		fmt.Fprintf(f, "\tif order == %#v {\n", order)
		fmt.Fprintf(f, "\t\treturn permute%d, true\n", i)
		fmt.Fprintf(f, "\t}\n")
	}
	fmt.Fprintf(f, "\treturn nil, false\n")
	fmt.Fprintf(f, "}\n")
}
